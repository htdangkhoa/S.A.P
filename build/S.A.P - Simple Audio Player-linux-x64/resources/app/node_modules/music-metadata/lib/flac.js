'use strict';
var strtok = require("strtok2");
var common_1 = require("./common");
var vorbis_1 = require("./vorbis");
var FlacParser = (function () {
    function FlacParser() {
    }
    FlacParser.getInstance = function () {
        return new FlacParser();
    };
    FlacParser.prototype.parse = function (stream, callback, done, readDuration, fileSize) {
        var currentState = startState;
        strtok.parse(stream, function (v, cb) {
            currentState = currentState.parse(callback, v, done);
            return currentState.getExpectedType();
        });
    };
    return FlacParser;
}());
FlacParser.headerType = 'vorbis';
/**
 * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:
 * ref: https://xiph.org/flac/format.html#metadata_block
 */
var BlockType;
(function (BlockType) {
    BlockType[BlockType["STREAMINFO"] = 0] = "STREAMINFO";
    BlockType[BlockType["PADDING"] = 1] = "PADDING";
    BlockType[BlockType["APPLICATION"] = 2] = "APPLICATION";
    BlockType[BlockType["SEEKTABLE"] = 3] = "SEEKTABLE";
    BlockType[BlockType["VORBIS_COMMENT"] = 4] = "VORBIS_COMMENT";
    BlockType[BlockType["CUESHEET"] = 5] = "CUESHEET";
    BlockType[BlockType["PICTURE"] = 6] = "PICTURE";
})(BlockType || (BlockType = {}));
var Metadata = (function () {
    function Metadata() {
    }
    return Metadata;
}());
Metadata.BlockHeader = {
    len: 4,
    get: function (buf, off) {
        return {
            lastBlock: common_1.default.strtokBITSET.get(buf, off, 7),
            type: common_1.default.getBitAllignedNumber(buf, off, 1, 7),
            length: common_1.default.strtokUINT24_BE.get(buf, off + 1)
        };
    }
};
/**
 * METADATA_BLOCK_DATA
 * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo
 */
Metadata.BlockStreamInfo = {
    len: 34,
    get: function (buf, off) {
        return {
            // The minimum block size (in samples) used in the stream.
            minimumBlockSize: strtok.UINT16_BE.get(buf, off),
            // The maximum block size (in samples) used in the stream.
            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.
            maximumBlockSize: strtok.UINT16_BE.get(buf, off + 2) / 1000,
            // The minimum frame size (in bytes) used in the stream.
            // May be 0 to imply the value is not known.
            minimumFrameSize: strtok.UINT24_BE.get(buf, off + 4),
            // The maximum frame size (in bytes) used in the stream.
            // May be 0 to imply the value is not known.
            maximumFrameSize: strtok.UINT24_BE.get(buf, off + 7),
            // Sample rate in Hz. Though 20 bits are available,
            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.
            // Also, a value of 0 is invalid.
            sampleRate: common_1.default.strtokUINT24_BE.get(buf, off + 10) >> 4,
            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),
            // (number of channels)-1. FLAC supports from 1 to 8 channels
            channels: common_1.default.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,
            // bits per sample)-1.
            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.
            bitsPerSample: common_1.default.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,
            // Total samples in stream.
            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.
            // A value of zero here means the number of total samples is unknown.
            totalSamples: common_1.default.getBitAllignedNumber(buf, off + 13, 4, 36),
            // the MD5 hash of the file (see notes for usage... it's a littly tricky)
            fileMD5: new strtok.BufferType(16).get(buf, off + 18)
        };
    }
};
var DataDecoder = (function () {
    function DataDecoder(data) {
        this.data = data;
        this.offset = 0;
    }
    DataDecoder.prototype.readInt32 = function () {
        var value = strtok.UINT32_LE.get(this.data, this.offset);
        this.offset += 4;
        return value;
    };
    DataDecoder.prototype.readStringUtf8 = function () {
        var len = this.readInt32();
        var value = this.data.toString('utf8', this.offset, this.offset + len);
        this.offset += len;
        return value;
    };
    return DataDecoder;
}());
// ToDo: same in ASF
var finishedState = {
    parse: function (callback) {
        return finishedState; // ToDo: correct?
    },
    getExpectedType: function () {
        return strtok.DONE;
    }
};
var BlockDataState = (function () {
    function BlockDataState(type, length, nextStateFactory) {
        this.type = type;
        this.length = length;
        this.nextStateFactory = nextStateFactory;
    }
    BlockDataState.prototype.parse = function (callback, data) {
        switch (this.type) {
            case BlockType.STREAMINFO:
                var blockStreamInfo = data;
                // Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo
                callback('format', 'dataformat', 'flac');
                callback('format', 'lossless', true);
                callback('format', 'headerType', FlacParser.headerType);
                callback('format', 'numberOfChannels', blockStreamInfo.channels);
                callback('format', 'bitsPerSample', blockStreamInfo.bitsPerSample);
                callback('format', 'sampleRate', blockStreamInfo.sampleRate);
                var duration = blockStreamInfo.totalSamples / blockStreamInfo.sampleRate;
                callback('format', 'duration', blockStreamInfo.totalSamples / blockStreamInfo.sampleRate);
                // callback('format', 'bitrate', fileSize / duration) // ToDo: exclude meta-data
                break;
            case BlockType.VORBIS_COMMENT:
                var decoder = new DataDecoder(data);
                decoder.readStringUtf8(); // vendor (skip)
                var commentListLength = decoder.readInt32();
                for (var i = 0; i < commentListLength; i++) {
                    var comment = decoder.readStringUtf8();
                    var split = comment.split('=');
                    callback(FlacParser.headerType, split[0].toUpperCase(), split[1]);
                }
                break;
            case BlockType.PICTURE:
                var picture = vorbis_1.default.readPicture(data);
                callback(FlacParser.headerType, 'METADATA_BLOCK_PICTURE', picture);
                break;
        }
        return this.nextStateFactory();
    };
    BlockDataState.prototype.getExpectedType = function () {
        switch (this.type) {
            case 0:
                return Metadata.BlockStreamInfo;
            default:
                return new strtok.BufferType(this.length);
        }
    };
    return BlockDataState;
}());
var blockHeaderState = {
    parse: function (callback, data, done) {
        var header = data;
        var followingStateFactory = header.lastBlock ? function () {
            done();
            return finishedState;
        } : function () {
            return blockHeaderState;
        };
        return new BlockDataState(header.type, header.length, followingStateFactory);
    },
    getExpectedType: function () {
        return Metadata.BlockHeader;
    }
};
var idState = {
    parse: function (callback, data, done) {
        if (data.toString() !== 'fLaC') {
            done(new Error('expected flac header but was not found'));
        }
        return blockHeaderState;
    },
    getExpectedType: function () {
        return new strtok.BufferType(4);
    }
};
var startState = {
    parse: function (callback) {
        return idState;
    },
    getExpectedType: function () {
        return strtok.DONE;
    }
};
module.exports = FlacParser.getInstance();
//# sourceMappingURL=flac.js.map