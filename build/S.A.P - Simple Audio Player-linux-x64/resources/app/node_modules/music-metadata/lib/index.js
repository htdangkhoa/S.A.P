/* jshint maxlen: 300 */
'use strict';
var events = require("events");
var fs = require("fs");
var strtok = require("strtok2");
var through = require("through");
var common_1 = require("./common");
var tagmap_1 = require("./tagmap");
var MusicMetadataParser = (function () {
    function MusicMetadataParser() {
        this.tagMap = new tagmap_1.default();
    }
    MusicMetadataParser.getInstance = function () {
        return new MusicMetadataParser();
    };
    MusicMetadataParser.toIntOrNull = function (str) {
        var cleaned = parseInt(str, 10);
        return isNaN(cleaned) ? null : cleaned;
    };
    /**
     * @param stream
     * @param opts
     *   .filesize=true  Return filesize
     *   .native=true    Will return original header in result
     * @param callback
     * @returns {EventEmitter}
     */
    MusicMetadataParser.prototype.parse = function (stream, opts, callback) {
        if (typeof opts === 'function') {
            callback = opts;
            opts = {};
        }
        var emitter = new events.EventEmitter();
        var fsize = function (cb) {
            if (opts.fileSize) {
                process.nextTick(function () {
                    cb(opts.fileSize);
                });
            }
            else if (stream.path) {
                fs.stat(stream.path, function (err, stats) {
                    if (err)
                        throw err;
                    cb(stats.size);
                });
            }
            else if (stream.fileSize) {
                stream.fileSize(cb);
            }
            else if (opts.duration) {
                emitter.emit('done', new Error('for non file streams, specify the size of the stream with a fileSize option'));
            }
        };
        // pipe to an internal stream so we aren't messing
        // with the stream passed to us by our users
        var istream = stream.pipe(through(null, null, { autoDestroy: false }));
        /**
         * Default present metadata properties
         */
        var metadata = {
            common: {
                artists: [],
                track: { no: null, of: null },
                disk: { no: null, of: null }
            },
            format: {
                duration: null
            }
        };
        var isDone = false;
        var hasReadData = false;
        var streamParser;
        var self = this;
        // ToDo: expose warnings to API
        var warning = [];
        function tagCallback(headerType, tag, value) {
            if (value === null) {
                warning.push('tag ' + tag + ' is null');
                return;
            }
            if (value === '') {
                warning.push('tag ' + tag + ' is empty');
                return;
            }
            if (headerType === 'format') {
                metadata.format[tag] = value;
            }
            else {
                self.setCommonTags(metadata.common, headerType, tag, value);
            }
            // Send native event, unless it's native name is the same as a common name
            if (!tagmap_1.default.isCommonTag(tag)) {
                emitter.emit(tag, value);
            }
            if (opts.native) {
                if (!metadata.hasOwnProperty(headerType)) {
                    metadata[headerType] = {}; // Register new native header headerType
                }
                if (self.tagMap.isNativeSingleton(headerType, tag)) {
                    metadata[headerType][tag] = value;
                }
                else {
                    (metadata[headerType][tag] = metadata[headerType][tag] ? metadata[headerType][tag] : []).push(value);
                }
            }
        }
        istream.once('data', function (result) {
            hasReadData = true;
            streamParser = common_1.default.getParserForMediaType(MusicMetadataParser.headerTypes, result);
            streamParser.parse(istream, function (headerType, tag, value) {
                tagCallback(headerType, tag, value);
            }, done, opts.duration, fsize);
            // re-emitting the first data chunk so the
            // parser picks the stream up from the start
            istream.emit('data', result);
        });
        istream.once('end', function () {
            if (!hasReadData) {
                done(new Error('Could not read any data from this stream'));
            }
            else {
                if (!isDone) {
                    isDone = true;
                    // Ensure the parsers 'end' handlers is executed first
                    if (streamParser && streamParser.end) {
                        streamParser.end(tagCallback, done);
                    }
                    else
                        done();
                }
            }
        });
        istream.on('close', onClose);
        function onClose() {
            done(new Error('Unexpected end of stream'));
        }
        function done(err) {
            isDone = true;
            istream.removeListener('close', onClose);
            if (!err) {
                /**
                 * If MusicBrainz defined artists, the artist may be a single combined field,
                 * otherwise artist may contain multiple artists.
                 */
                if (metadata.common.artists && metadata.common.artists.length > 0) {
                    metadata.common.artist = metadata.common.artist[0];
                }
                else {
                    if (metadata.common.artist) {
                        metadata.common.artists = metadata.common.artist;
                        if (metadata.common.artist.length > 1) {
                            delete metadata.common.artist;
                        }
                        else {
                            metadata.common.artist = metadata.common.artist[0];
                        }
                    }
                }
                // We only emit aliased events once the 'done' event has been raised,
                // this is because an alias like 'artist' could have values split
                // over many data chunks.
                for (var _alias in metadata.common) {
                    if (metadata.common.hasOwnProperty(_alias)) {
                        emitter.emit(_alias, metadata.common[_alias]);
                    }
                }
            }
            if (callback) {
                callback(err, metadata);
            }
            return strtok.DONE;
        }
        return emitter;
    };
    /**
     * Process and set common tags
     * @param comTags Target metadata to wrote common tags to
     * @param type    Native headerType e.g.: 'm4a' | 'asf' | 'id3v1.1' | 'id3v2.4' | 'vorbis'
     * @param tag     Native tag
     * @param value   Native tag value
     */
    MusicMetadataParser.prototype.setCommonTags = function (comTags, type, tag, value) {
        switch (type) {
            /*
             case 'vorbis':
             switch (tag) {
      
             case 'TRACKTOTAL':
             case 'TOTALTRACKS': // rare tag
             comTags.track.of = MusicMetadataParser.toIntOrNull(value)
             return
      
             case 'DISCTOTAL':
             case 'TOTALDISCS': // rare tag
             comTags.disk.of = MusicMetadataParser.toIntOrNull(value)
             return
             default:
             }
             break
             */
            case 'id3v2.3':
            case 'id3v2.4':
                switch (tag) {
                    /*
                     case 'TXXX':
                     tag += ':' + value.description
                     value = value.text
                     break*/
                    case 'UFID':
                        if (value.owner_identifier === 'http://musicbrainz.org') {
                            tag += ':' + value.owner_identifier;
                            value = common_1.default.decodeString(value.identifier, 'iso-8859-1');
                        }
                        break;
                    case 'PRIV':
                        switch (value.owner_identifier) {
                            // decode Windows Media Player
                            case 'AverageLevel':
                            case 'PeakValue':
                                tag += ':' + value.owner_identifier;
                                value = common_1.default.strtokUINT32_LE.get(value.data, 0);
                                break;
                            default:
                        }
                        break;
                    default:
                }
                break;
            default:
        }
        // Convert native tag event to common (aliased) event
        var alias = this.tagMap.getCommonName(type, tag);
        if (alias) {
            // Common tag (alias) found
            // check if we need to do something special with common tag
            // if the event has been aliased then we need to clean it before
            // it is emitted to the user. e.g. genre (20) -> Electronic
            switch (alias) {
                case 'genre':
                    value = common_1.default.parseGenre(value);
                    break;
                case 'picture':
                    value = this.cleanupPicture(value);
                    break;
                case 'totaltracks':
                    comTags.track.of = MusicMetadataParser.toIntOrNull(value);
                    return;
                case 'totaldiscs':
                    comTags.disk.of = MusicMetadataParser.toIntOrNull(value);
                    return;
                case 'track':
                case 'disk':
                    var of = comTags[alias].of; // store of value, maybe maybe overwritten
                    comTags[alias] = this.cleanupTrack(value);
                    comTags[alias].of = of != null ? of : comTags[alias].of;
                    return;
                case 'year':
                case 'originalyear':
                    value = parseInt(value, 10);
                    break;
                case 'date':
                    // ToDo: be more strict on 'YYYY...'
                    // if (/^\d{4}\-(0?[1-9]|1[012])\-(0?[1-9]|[12][0-9]|3[01])$/.test(value)) {
                    comTags.year = parseInt(value.substr(0, 4), 10);
                    break;
                default:
            }
            if (alias !== 'artist' && tagmap_1.default.isSingleton(alias)) {
                comTags[alias] = value;
            }
            else {
                if (comTags.hasOwnProperty(alias)) {
                    comTags[alias].push(value);
                }
                else {
                    // if we haven't previously seen this tag then
                    // initialize it to an array, ready for values to be entered
                    comTags[alias] = [value];
                }
            }
        }
    };
    // TODO: a string of 1of1 would fail to be converted
    // converts 1/10 to no : 1, of : 10
    // or 1 to no : 1, of : 0
    MusicMetadataParser.prototype.cleanupTrack = function (origVal) {
        var split = origVal.toString().split('/');
        return {
            no: parseInt(split[0], 10) || null,
            of: parseInt(split[1], 10) || null
        };
    };
    MusicMetadataParser.prototype.cleanupPicture = function (picture) {
        var newFormat;
        if (picture.format) {
            var split = picture.format.toLowerCase().split('/');
            newFormat = (split.length > 1) ? split[1] : split[0];
            if (newFormat === 'jpeg')
                newFormat = 'jpg';
        }
        else {
            newFormat = 'jpg';
        }
        return { format: newFormat, data: picture.data };
    };
    return MusicMetadataParser;
}());
MusicMetadataParser.headerTypes = [
    {
        buf: common_1.default.asfGuidBuf,
        tag: require('./asf')
    },
    {
        buf: new Buffer('ID3'),
        tag: require('./id3v2')
    },
    {
        buf: new Buffer('ftypM4A'),
        tag: require('./id4'),
        offset: 4
    },
    {
        buf: new Buffer('ftypmp42'),
        tag: require('./id4'),
        offset: 4
    },
    {
        buf: new Buffer('OggS'),
        tag: require('./ogg')
    },
    {
        buf: new Buffer('fLaC'),
        tag: require('./flac')
    },
    {
        buf: new Buffer('MAC'),
        tag: require('./monkeysaudio')
    }
];
/**
 * Parse audio stream
 * @param stream
 * @param opts
 *   .filesize=true  Return filesize
 *   .native=true    Will return original header in result
 * @param callback
 * @returns {*|EventEmitter}
 */
function parseStream(stream, opts, callback) {
    return MusicMetadataParser.getInstance().parse(stream, opts, callback);
}
exports.parseStream = parseStream;
//# sourceMappingURL=index.js.map