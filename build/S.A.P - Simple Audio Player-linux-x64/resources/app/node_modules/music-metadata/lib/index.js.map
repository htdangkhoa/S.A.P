{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"],"names":[],"mappings":"AAAA,wBAAwB;AACxB,YAAY,CAAC;AACb,+BAAiC;AACjC,uBAAyB;AACzB,gCAAkC;AAClC,iCAAmC;AACnC,mCAA8B;AAE9B,mCAA8B;AAyJ9B;IAAA;QA4CU,WAAM,GAAG,IAAI,gBAAM,EAAE,CAAC;IA+ThC,CAAC;IAzWe,+BAAW,GAAzB;QACE,MAAM,CAAC,IAAI,mBAAmB,EAAE,CAAC;IACnC,CAAC;IAmCc,+BAAW,GAA1B,UAA2B,GAAW;QACpC,IAAM,OAAO,GAAG,QAAQ,CAAC,GAAG,EAAE,EAAE,CAAC,CAAC;QAClC,MAAM,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,IAAI,GAAG,OAAO,CAAC;IACzC,CAAC;IAID;;;;;;;OAOG;IACI,mCAAK,GAAZ,UAAa,MAAsB,EAAE,IAAc,EAAE,QAAuB;QAC1E,EAAE,CAAC,CAAC,OAAO,IAAI,KAAK,UAAU,CAAC,CAAC,CAAC;YAC/B,QAAQ,GAAI,IAAsB,CAAC;YACnC,IAAI,GAAG,EAAE,CAAC;QACZ,CAAC;QAED,IAAM,OAAO,GAAG,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC;QAE1C,IAAM,KAAK,GAAG,UAAC,EAAE;YACf,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBAClB,OAAO,CAAC,QAAQ,CAAC;oBACf,EAAE,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;gBACpB,CAAC,CAAC,CAAC;YACL,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAE,MAAqB,CAAC,IAAI,CAAC,CAAC,CAAC;gBACvC,EAAE,CAAC,IAAI,CAAE,MAAqB,CAAC,IAAI,EAAE,UAAC,GAAG,EAAE,KAAK;oBAC9C,EAAE,CAAC,CAAC,GAAG,CAAC;wBAAC,MAAM,GAAG,CAAC;oBACnB,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gBACjB,CAAC,CAAC,CAAC;YACL,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAE,MAAoB,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACzC,MAAoB,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;YACrC,CAAC;YAAC,IAAI,CAAC,EAAE,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACzB,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,KAAK,CAAC,6EAA6E,CAAC,CAAC,CAAC;YACjH,CAAC;QACH,CAAC,CAAC;QAEF,kDAAkD;QAClD,4CAA4C;QAC5C,IAAM,OAAO,GAAG,MAAM,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,EAAE,IAAI,EAAE,EAAC,WAAW,EAAE,KAAK,EAAC,CAAC,CAAC,CAAC;QAEvE;;WAEG;QACH,IAAM,QAAQ,GAAY;YACxB,MAAM,EAAE;gBACN,OAAO,EAAE,EAAE;gBACX,KAAK,EAAE,EAAC,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAC;gBAC3B,IAAI,EAAE,EAAC,EAAE,EAAE,IAAI,EAAE,EAAE,EAAE,IAAI,EAAC;aAC3B;YACD,MAAM,EAAE;gBACN,QAAQ,EAAE,IAAI;aACf;SACF,CAAC;QAEF,IAAI,MAAM,GAAG,KAAK,CAAC;QACnB,IAAI,WAAW,GAAG,KAAK,CAAC;QACxB,IAAI,YAA2B,CAAC;QAChC,IAAM,IAAI,GAAG,IAAI,CAAC;QAElB,+BAA+B;QAC/B,IAAM,OAAO,GAAa,EAAE,CAAC;QAE7B,qBAAqB,UAAU,EAAE,GAAG,EAAE,KAAK;YACzC,EAAE,CAAC,CAAC,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC;gBACnB,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,UAAU,CAAC,CAAC;gBACxC,MAAM,CAAC;YACT,CAAC;YAED,EAAE,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC,CAAC,CAAC;gBACjB,OAAO,CAAC,IAAI,CAAC,MAAM,GAAG,GAAG,GAAG,WAAW,CAAC,CAAC;gBACzC,MAAM,CAAC;YACT,CAAC;YAED,EAAE,CAAC,CAAC,UAAU,KAAK,QAAQ,CAAC,CAAC,CAAC;gBAC5B,QAAQ,CAAC,MAAM,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;YAC/B,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,IAAI,CAAC,aAAa,CAAC,QAAQ,CAAC,MAAM,EAAE,UAAwB,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YAC5E,CAAC;YAED,0EAA0E;YAC1E,EAAE,CAAC,CAAC,CAAC,gBAAM,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC7B,OAAO,CAAC,IAAI,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;YAC3B,CAAC;YAED,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC,CAAC;gBAChB,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC,CAAC,CAAC;oBACzC,QAAQ,CAAC,UAAU,CAAC,GAAG,EAAE,CAAC,CAAC,wCAAwC;gBACrE,CAAC;gBAED,EAAE,CAAC,CAAC,IAAI,CAAC,MAAM,CAAC,iBAAiB,CAAC,UAAU,EAAE,GAAG,CAAC,CAAC,CAAC,CAAC;oBACnD,QAAQ,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;gBACpC,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,GAAG,QAAQ,CAAC,UAAU,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBACvG,CAAC;YACH,CAAC;QACH,CAAC;QAED,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,UAAC,MAAM;YAC1B,WAAW,GAAG,IAAI,CAAC;YACnB,YAAY,GAAG,gBAAM,CAAC,qBAAqB,CAAC,mBAAmB,CAAC,WAAW,EAAE,MAAM,CAAC,CAAC;YACrF,YAAY,CAAC,KAAK,CAAC,OAAO,EAAE,UAAC,UAAU,EAAE,GAAG,EAAE,KAAK;gBACjD,WAAW,CAAC,UAAU,EAAE,GAAG,EAAE,KAAK,CAAC,CAAC;YACtC,CAAC,EAAE,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE,KAAK,CAAC,CAAC;YAC/B,0CAA0C;YAC1C,4CAA4C;YAC5C,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;QAC/B,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE;YAClB,EAAE,CAAC,CAAC,CAAC,WAAW,CAAC,CAAC,CAAC;gBACjB,IAAI,CAAC,IAAI,KAAK,CAAC,0CAA0C,CAAC,CAAC,CAAC;YAC9D,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,CAAC,MAAM,CAAC,CAAC,CAAC;oBACZ,MAAM,GAAG,IAAI,CAAC;oBACd,sDAAsD;oBACtD,EAAE,CAAC,CAAC,YAAY,IAAI,YAAY,CAAC,GAAG,CAAC,CAAC,CAAC;wBACrC,YAAY,CAAC,GAAG,CAAC,WAAW,EAAE,IAAI,CAAC,CAAC;oBACtC,CAAC;oBAAC,IAAI;wBAAC,IAAI,EAAE,CAAC;gBAChB,CAAC;YACH,CAAC;QAEH,CAAC,CAAC,CAAC;QAEH,OAAO,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;QAE7B;YACE,IAAI,CAAC,IAAI,KAAK,CAAC,0BAA0B,CAAC,CAAC,CAAC;QAC9C,CAAC;QAED,cAAc,GAAW;YACvB,MAAM,GAAG,IAAI,CAAC;YACd,OAAO,CAAC,cAAc,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;YAEzC,EAAE,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;gBACT;;;mBAGG;gBACH,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,OAAO,IAAI,QAAQ,CAAC,MAAM,CAAC,OAAO,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;oBAClE,QAAQ,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;gBACrD,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;wBAC3B,QAAQ,CAAC,MAAM,CAAC,OAAO,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAa,CAAC;wBACxD,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;4BACtC,OAAO,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC;wBAChC,CAAC;wBAAC,IAAI,CAAC,CAAC;4BACN,QAAQ,CAAC,MAAM,CAAC,MAAM,GAAG,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBACrD,CAAC;oBACH,CAAC;gBACH,CAAC;gBAED,qEAAqE;gBACrE,iEAAiE;gBACjE,yBAAyB;gBACzB,GAAG,CAAC,CAAC,IAAM,MAAM,IAAI,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC;oBACrC,EAAE,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC;wBAC3C,OAAO,CAAC,IAAI,CAAC,MAAM,EAAE,QAAQ,CAAC,MAAM,CAAC,MAAM,CAAC,CAAC,CAAC;oBAChD,CAAC;gBACH,CAAC;YACH,CAAC;YAED,EAAE,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACb,QAAQ,CAAC,GAAG,EAAE,QAAQ,CAAC,CAAC;YAC1B,CAAC;YACD,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QACrB,CAAC;QAED,MAAM,CAAC,OAAO,CAAC;IACjB,CAAC;IAED;;;;;;OAMG;IACK,2CAAa,GAArB,UAAsB,OAAO,EAAE,IAAgB,EAAE,GAAW,EAAE,KAAU;QAEtE,MAAM,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;YACb;;;;;;;;;;;;;;;;eAgBG;YAEH,KAAK,SAAS,CAAC;YACf,KAAK,SAAS;gBACZ,MAAM,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;oBAEZ;;;;4BAIQ;oBAER,KAAK,MAAM;wBACT,EAAE,CAAC,CAAC,KAAK,CAAC,gBAAgB,KAAK,wBAAwB,CAAC,CAAC,CAAC;4BACxD,GAAG,IAAI,GAAG,GAAG,KAAK,CAAC,gBAAgB,CAAC;4BACpC,KAAK,GAAG,gBAAM,CAAC,YAAY,CAAC,KAAK,CAAC,UAAU,EAAE,YAAY,CAAC,CAAC;wBAC9D,CAAC;wBACD,KAAK,CAAC;oBAER,KAAK,MAAM;wBACT,MAAM,CAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,CAAC;4BAC/B,8BAA8B;4BAC9B,KAAK,cAAc,CAAC;4BACpB,KAAK,WAAW;gCACd,GAAG,IAAI,GAAG,GAAG,KAAK,CAAC,gBAAgB,CAAC;gCACpC,KAAK,GAAG,gBAAM,CAAC,eAAe,CAAC,GAAG,CAAC,KAAK,CAAC,IAAI,EAAE,CAAC,CAAC,CAAC;gCAClD,KAAK,CAAC;4BACR,QAAQ;wBAEV,CAAC;wBACD,KAAK,CAAC;oBAER,QAAQ;gBAEV,CAAC;gBACD,KAAK,CAAC;YACR,QAAQ;QAEV,CAAC;QAED,qDAAqD;QACrD,IAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,aAAa,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QAEnD,EAAE,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;YACV,2BAA2B;YAE3B,2DAA2D;YAC3D,gEAAgE;YAChE,2DAA2D;YAC3D,MAAM,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC;gBACd,KAAK,OAAO;oBACV,KAAK,GAAG,gBAAM,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;oBACjC,KAAK,CAAC;gBAER,KAAK,SAAS;oBACZ,KAAK,GAAG,IAAI,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC;oBACnC,KAAK,CAAC;gBAER,KAAK,aAAa;oBAChB,OAAO,CAAC,KAAK,CAAC,EAAE,GAAG,mBAAmB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;oBAC1D,MAAM,CAAC;gBAET,KAAK,YAAY;oBACf,OAAO,CAAC,IAAI,CAAC,EAAE,GAAG,mBAAmB,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;oBACzD,MAAM,CAAC;gBAET,KAAK,OAAO,CAAC;gBACb,KAAK,MAAM;oBACT,IAAM,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,0CAA0C;oBACxE,OAAO,CAAC,KAAK,CAAC,GAAG,IAAI,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;oBAC1C,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,GAAG,EAAE,IAAI,IAAI,GAAG,EAAE,GAAG,OAAO,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;oBACxD,MAAM,CAAC;gBAET,KAAK,MAAM,CAAC;gBACZ,KAAK,cAAc;oBACjB,KAAK,GAAG,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;oBAC5B,KAAK,CAAC;gBAER,KAAK,MAAM;oBACT,oCAAoC;oBACpC,4EAA4E;oBAC5E,OAAO,CAAC,IAAI,GAAG,QAAQ,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC;oBAChD,KAAK,CAAC;gBAER,QAAQ;YAEV,CAAC;YAED,EAAE,CAAC,CAAC,KAAK,KAAK,QAAQ,IAAI,gBAAM,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;gBACpD,OAAO,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;YACzB,CAAC;YAAC,IAAI,CAAC,CAAC;gBACN,EAAE,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;oBAClC,OAAO,CAAC,KAAK,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;gBAC7B,CAAC;gBAAC,IAAI,CAAC,CAAC;oBACN,8CAA8C;oBAC9C,4DAA4D;oBAC5D,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC;gBAC3B,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;IAED,oDAAoD;IACpD,mCAAmC;IACnC,yBAAyB;IACjB,0CAAY,GAApB,UAAqB,OAAwB;QAC3C,IAAM,KAAK,GAAG,OAAO,CAAC,QAAQ,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QAC5C,MAAM,CAAC;YACL,EAAE,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,IAAI;YAClC,EAAE,EAAE,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,IAAI;SACnC,CAAC;IACJ,CAAC;IAEO,4CAAc,GAAtB,UAAuB,OAAO;QAC5B,IAAI,SAAS,CAAC;QACd,EAAE,CAAC,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC,CAAC;YACnB,IAAM,KAAK,GAAG,OAAO,CAAC,MAAM,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;YACtD,SAAS,GAAG,CAAC,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC,CAAC,CAAC,CAAC;YACrD,EAAE,CAAC,CAAC,SAAS,KAAK,MAAM,CAAC;gBAAC,SAAS,GAAG,KAAK,CAAC;QAC9C,CAAC;QAAC,IAAI,CAAC,CAAC;YACN,SAAS,GAAG,KAAK,CAAC;QACpB,CAAC;QACD,MAAM,CAAC,EAAC,MAAM,EAAE,SAAS,EAAE,IAAI,EAAE,OAAO,CAAC,IAAI,EAAC,CAAC;IACjD,CAAC;IACH,0BAAC;AAAD,CAAC,AA3WD;AAMiB,+BAAW,GAAG;IAC3B;QACE,GAAG,EAAE,gBAAM,CAAC,UAAU;QACtB,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC;KACtB;IACD;QACE,GAAG,EAAE,IAAI,MAAM,CAAC,KAAK,CAAC;QACtB,GAAG,EAAE,OAAO,CAAC,SAAS,CAAC;KACxB;IACD;QACE,GAAG,EAAE,IAAI,MAAM,CAAC,SAAS,CAAC;QAC1B,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC;QACrB,MAAM,EAAE,CAAC;KACV;IACD;QACE,GAAG,EAAE,IAAI,MAAM,CAAC,UAAU,CAAC;QAC3B,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC;QACrB,MAAM,EAAE,CAAC;KACV;IACD;QACE,GAAG,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC;QACvB,GAAG,EAAE,OAAO,CAAC,OAAO,CAAC;KACtB;IACD;QACE,GAAG,EAAE,IAAI,MAAM,CAAC,MAAM,CAAC;QACvB,GAAG,EAAE,OAAO,CAAC,QAAQ,CAAC;KACvB;IACD;QACE,GAAG,EAAE,IAAI,MAAM,CAAC,KAAK,CAAC;QACtB,GAAG,EAAE,OAAO,CAAC,gBAAgB,CAAC;KAC/B;CACF,CAAC;AAwUJ;;;;;;;;GAQG;AACH,qBAA4B,MAAsB,EAAE,IAAc,EAAE,QAAuB;IACzF,MAAM,CAAC,mBAAmB,CAAC,WAAW,EAAE,CAAC,KAAK,CAAC,MAAM,EAAE,IAAI,EAAE,QAAQ,CAAC,CAAC;AACzE,CAAC;AAFD,kCAEC","sourcesContent":["/* jshint maxlen: 300 */\n'use strict';\nimport * as events from 'events';\nimport * as fs from 'fs';\nimport * as strtok from 'strtok2';\nimport * as through from 'through';\nimport common from './common';\nimport {IStreamParser} from './parser';\nimport TagMap from './tagmap';\nimport {HeaderType} from './tagmap';\nimport EventEmitter = NodeJS.EventEmitter;\nimport {ReadStream} from 'fs';\nimport ReadableStream = NodeJS.ReadableStream;\n\nexport interface IPicture {\n  format: string,\n  data: Uint8Array;\n}\n\nexport interface ICommonTagsResult {\n  track: { no: number, of: number },\n  disk: { no: number, of: number },\n  year?: number,\n  title?: string,\n  artist?: string, // ToDo: string[] is only used internal\n  artists?: string[],\n  albumartist?: string,\n  album?: string,\n  date?: string,\n  originaldate?: string,\n  originalyear?: number,\n  comment?: string,\n  genre?: string[];\n  picture?: IPicture[];\n  composer?: string[];\n  lyrics?: string[],\n  albumsort?: string,\n  titlesort?: string,\n  work?: string,\n  artistsort?: string,\n  albumartistsort?: string,\n  composersort?: string[],\n  lyricist?: string[],\n  writer?: string[],\n  conductor?: string[],\n  remixer?: string[],\n  arranger?: string[],\n  engineer?: string[],\n  producer?: string[],\n  djmixer?: string[],\n  mixer?: string[],\n  label?: string,\n  grouping?: string[],\n  subtitle?: string[],\n  discsubtitle?: string[],\n  totaltracks?: string,\n  totaldiscs?: string,\n  compilation?: string,\n  _rating?: string,\n  bpm?: string,\n  mood?: string,\n  media?: string,\n  catalognumber?: string,\n  show?: string,\n  showsort?: string,\n  podcast?: string,\n  podcasturl?: string,\n  releasestatus?: string,\n  releasetype?: string[],\n  releasecountry?: string,\n  script?: string,\n  language?: string,\n  copyright?: string,\n  license?: string,\n  encodedby?: string,\n  encodersettings?: string,\n  gapless?: string,\n  barcode?: string, // ToDo: multiple??\n  isrc?: string,\n  asin?: string,\n  musicbrainz_recordingid?: string,\n  musicbrainz_trackid?: string,\n  musicbrainz_albumid?: string,\n  musicbrainz_artistid?: string[],\n  musicbrainz_albumartistid?: string[],\n  musicbrainz_releasegroupid?: string,\n  musicbrainz_workid?: string,\n  musicbrainz_trmid?: string,\n  musicbrainz_discid?: string,\n  acoustid_id?: string,\n  acoustid_fingerprint?: string,\n  musicip_puid?: string,\n  musicip_fingerprint?: string,\n  website?: string,\n  'performer:instrument'?: string[],\n  averageLevel?: number,\n  peakLevel?: number;\n}\n\nexport interface IFormat {\n\n  dataformat?: string, // ToDo: make mandatory\n\n  type?: HeaderType, // ToDo: make mandatory\n\n  /**\n   * Duration in seconds\n   */\n  duration?: number,\n\n  /**\n   * Number bits per second of encoded audio file\n   */\n  bitrate?: number,\n\n  /**\n   * Sampling rate in Samples per second (S/s)\n   */\n  sampleRate?: number,\n\n  /**\n   * Audio bit depth\n   */\n  bitsPerSample?: number,\n\n  /**\n   * Encoder name, e.g.:\n   */\n  encoder?: string,\n\n  /**\n   * Codec profile\n   */\n  codecProfile?: string,\n\n  lossless?: boolean,\n\n  /**\n   * Number of audio channels\n   */\n  numberOfChannels?: number,\n}\n\nexport interface IResult {\n  common: ICommonTagsResult,\n  format: IFormat;\n}\n\nexport type ICallbackType = (error?: Error, result?: IResult) => void;\n\nexport interface IOptions {\n  path?: string,\n  fileSize?: string,\n  native?: boolean,\n  duration?: boolean;\n}\n\nexport interface IFileSize {\n  fileSize?: (size: number) => void;\n}\n\nclass MusicMetadataParser {\n\n  public static getInstance(): MusicMetadataParser {\n    return new MusicMetadataParser();\n  }\n\n  private static headerTypes = [\n    {\n      buf: common.asfGuidBuf,\n      tag: require('./asf')\n    },\n    {\n      buf: new Buffer('ID3'),\n      tag: require('./id3v2')\n    },\n    {\n      buf: new Buffer('ftypM4A'),\n      tag: require('./id4'),\n      offset: 4\n    },\n    {\n      buf: new Buffer('ftypmp42'),\n      tag: require('./id4'),\n      offset: 4\n    },\n    {\n      buf: new Buffer('OggS'),\n      tag: require('./ogg')\n    },\n    {\n      buf: new Buffer('fLaC'),\n      tag: require('./flac')\n    },\n    {\n      buf: new Buffer('MAC'),\n      tag: require('./monkeysaudio')\n    }\n  ];\n\n  private static toIntOrNull(str: string): number {\n    const cleaned = parseInt(str, 10);\n    return isNaN(cleaned) ? null : cleaned;\n  }\n\n  private tagMap = new TagMap();\n\n  /**\n   * @param stream\n   * @param opts\n   *   .filesize=true  Return filesize\n   *   .native=true    Will return original header in result\n   * @param callback\n   * @returns {EventEmitter}\n   */\n  public parse(stream: ReadableStream, opts: IOptions, callback: ICallbackType): EventEmitter {\n    if (typeof opts === 'function') {\n      callback = (opts as ICallbackType);\n      opts = {};\n    }\n\n    const emitter = new events.EventEmitter();\n\n    const fsize = (cb) => {\n      if (opts.fileSize) {\n        process.nextTick(() => {\n          cb(opts.fileSize);\n        });\n      } else if ((stream as ReadStream).path) {\n        fs.stat((stream as ReadStream).path, (err, stats) => {\n          if (err) throw err;\n          cb(stats.size);\n        });\n      } else if ((stream as IFileSize).fileSize) {\n        (stream as IFileSize).fileSize(cb);\n      } else if (opts.duration) {\n        emitter.emit('done', new Error('for non file streams, specify the size of the stream with a fileSize option'));\n      }\n    };\n\n    // pipe to an internal stream so we aren't messing\n    // with the stream passed to us by our users\n    const istream = stream.pipe(through(null, null, {autoDestroy: false}));\n\n    /**\n     * Default present metadata properties\n     */\n    const metadata: IResult = {\n      common: {\n        artists: [],\n        track: {no: null, of: null},\n        disk: {no: null, of: null}\n      },\n      format: {\n        duration: null\n      }\n    };\n\n    let isDone = false;\n    let hasReadData = false;\n    let streamParser: IStreamParser;\n    const self = this;\n\n    // ToDo: expose warnings to API\n    const warning: string[] = [];\n\n    function tagCallback(headerType, tag, value) {\n      if (value === null) {\n        warning.push('tag ' + tag + ' is null');\n        return;\n      }\n\n      if (value === '') {\n        warning.push('tag ' + tag + ' is empty');\n        return;\n      }\n\n      if (headerType === 'format') {\n        metadata.format[tag] = value;\n      } else {\n        self.setCommonTags(metadata.common, headerType as HeaderType, tag, value);\n      }\n\n      // Send native event, unless it's native name is the same as a common name\n      if (!TagMap.isCommonTag(tag)) {\n        emitter.emit(tag, value);\n      }\n\n      if (opts.native) {\n        if (!metadata.hasOwnProperty(headerType)) {\n          metadata[headerType] = {}; // Register new native header headerType\n        }\n\n        if (self.tagMap.isNativeSingleton(headerType, tag)) {\n          metadata[headerType][tag] = value;\n        } else {\n          (metadata[headerType][tag] = metadata[headerType][tag] ? metadata[headerType][tag] : []).push(value);\n        }\n      }\n    }\n\n    istream.once('data', (result) => {\n      hasReadData = true;\n      streamParser = common.getParserForMediaType(MusicMetadataParser.headerTypes, result);\n      streamParser.parse(istream, (headerType, tag, value) => {\n        tagCallback(headerType, tag, value);\n      }, done, opts.duration, fsize);\n      // re-emitting the first data chunk so the\n      // parser picks the stream up from the start\n      istream.emit('data', result);\n    });\n\n    istream.once('end', () => {\n      if (!hasReadData) {\n        done(new Error('Could not read any data from this stream'));\n      } else {\n        if (!isDone) {\n          isDone = true;\n          // Ensure the parsers 'end' handlers is executed first\n          if (streamParser && streamParser.end) {\n            streamParser.end(tagCallback, done);\n          } else done();\n        }\n      }\n\n    });\n\n    istream.on('close', onClose);\n\n    function onClose() {\n      done(new Error('Unexpected end of stream'));\n    }\n\n    function done(err?: Error) {\n      isDone = true;\n      istream.removeListener('close', onClose);\n\n      if (!err) {\n        /**\n         * If MusicBrainz defined artists, the artist may be a single combined field,\n         * otherwise artist may contain multiple artists.\n         */\n        if (metadata.common.artists && metadata.common.artists.length > 0) {\n          metadata.common.artist = metadata.common.artist[0];\n        } else {\n          if (metadata.common.artist) {\n            metadata.common.artists = metadata.common.artist as any;\n            if (metadata.common.artist.length > 1) {\n              delete metadata.common.artist;\n            } else {\n              metadata.common.artist = metadata.common.artist[0];\n            }\n          }\n        }\n\n        // We only emit aliased events once the 'done' event has been raised,\n        // this is because an alias like 'artist' could have values split\n        // over many data chunks.\n        for (const _alias in metadata.common) {\n          if (metadata.common.hasOwnProperty(_alias)) {\n            emitter.emit(_alias, metadata.common[_alias]);\n          }\n        }\n      }\n\n      if (callback) {\n        callback(err, metadata);\n      }\n      return strtok.DONE;\n    }\n\n    return emitter;\n  }\n\n  /**\n   * Process and set common tags\n   * @param comTags Target metadata to wrote common tags to\n   * @param type    Native headerType e.g.: 'm4a' | 'asf' | 'id3v1.1' | 'id3v2.4' | 'vorbis'\n   * @param tag     Native tag\n   * @param value   Native tag value\n   */\n  private setCommonTags(comTags, type: HeaderType, tag: string, value: any) {\n\n    switch (type) {\n      /*\n       case 'vorbis':\n       switch (tag) {\n\n       case 'TRACKTOTAL':\n       case 'TOTALTRACKS': // rare tag\n       comTags.track.of = MusicMetadataParser.toIntOrNull(value)\n       return\n\n       case 'DISCTOTAL':\n       case 'TOTALDISCS': // rare tag\n       comTags.disk.of = MusicMetadataParser.toIntOrNull(value)\n       return\n       default:\n       }\n       break\n       */\n\n      case 'id3v2.3':\n      case 'id3v2.4':\n        switch (tag) {\n\n          /*\n           case 'TXXX':\n           tag += ':' + value.description\n           value = value.text\n           break*/\n\n          case 'UFID': // decode MusicBrainz Recording Id\n            if (value.owner_identifier === 'http://musicbrainz.org') {\n              tag += ':' + value.owner_identifier;\n              value = common.decodeString(value.identifier, 'iso-8859-1');\n            }\n            break;\n\n          case 'PRIV':\n            switch (value.owner_identifier) {\n              // decode Windows Media Player\n              case 'AverageLevel':\n              case 'PeakValue':\n                tag += ':' + value.owner_identifier;\n                value = common.strtokUINT32_LE.get(value.data, 0);\n                break;\n              default:\n              // Unknown PRIV owner-identifier\n            }\n            break;\n\n          default:\n          // nothing to do\n        }\n        break;\n      default:\n      // nothing to do\n    }\n\n    // Convert native tag event to common (aliased) event\n    const alias = this.tagMap.getCommonName(type, tag);\n\n    if (alias) {\n      // Common tag (alias) found\n\n      // check if we need to do something special with common tag\n      // if the event has been aliased then we need to clean it before\n      // it is emitted to the user. e.g. genre (20) -> Electronic\n      switch (alias) {\n        case 'genre':\n          value = common.parseGenre(value);\n          break;\n\n        case 'picture':\n          value = this.cleanupPicture(value);\n          break;\n\n        case 'totaltracks':\n          comTags.track.of = MusicMetadataParser.toIntOrNull(value);\n          return;\n\n        case 'totaldiscs':\n          comTags.disk.of = MusicMetadataParser.toIntOrNull(value);\n          return;\n\n        case 'track':\n        case 'disk':\n          const of = comTags[alias].of; // store of value, maybe maybe overwritten\n          comTags[alias] = this.cleanupTrack(value);\n          comTags[alias].of = of != null ? of : comTags[alias].of;\n          return;\n\n        case 'year':\n        case 'originalyear':\n          value = parseInt(value, 10);\n          break;\n\n        case 'date':\n          // ToDo: be more strict on 'YYYY...'\n          // if (/^\\d{4}\\-(0?[1-9]|1[012])\\-(0?[1-9]|[12][0-9]|3[01])$/.test(value)) {\n          comTags.year = parseInt(value.substr(0, 4), 10);\n          break;\n\n        default:\n        // nothing to do\n      }\n\n      if (alias !== 'artist' && TagMap.isSingleton(alias)) {\n        comTags[alias] = value;\n      } else {\n        if (comTags.hasOwnProperty(alias)) {\n          comTags[alias].push(value);\n        } else {\n          // if we haven't previously seen this tag then\n          // initialize it to an array, ready for values to be entered\n          comTags[alias] = [value];\n        }\n      }\n    }\n  }\n\n  // TODO: a string of 1of1 would fail to be converted\n  // converts 1/10 to no : 1, of : 10\n  // or 1 to no : 1, of : 0\n  private cleanupTrack(origVal: number | string) {\n    const split = origVal.toString().split('/');\n    return {\n      no: parseInt(split[0], 10) || null,\n      of: parseInt(split[1], 10) || null\n    };\n  }\n\n  private cleanupPicture(picture) {\n    let newFormat;\n    if (picture.format) {\n      const split = picture.format.toLowerCase().split('/');\n      newFormat = (split.length > 1) ? split[1] : split[0];\n      if (newFormat === 'jpeg') newFormat = 'jpg';\n    } else {\n      newFormat = 'jpg';\n    }\n    return {format: newFormat, data: picture.data};\n  }\n}\n\n/**\n * Parse audio stream\n * @param stream\n * @param opts\n *   .filesize=true  Return filesize\n *   .native=true    Will return original header in result\n * @param callback\n * @returns {*|EventEmitter}\n */\nexport function parseStream(stream: ReadableStream, opts: IOptions, callback: ICallbackType) {\n  return MusicMetadataParser.getInstance().parse(stream, opts, callback);\n}\n"]}