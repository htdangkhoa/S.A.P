'use strict';
var strtok = require('strtok2');
var common_1 = require('./common');
var DataType;
(function (DataType) {
    DataType[DataType["text_utf8"] = 0] = "text_utf8";
    DataType[DataType["binary"] = 1] = "binary";
    DataType[DataType["external_info"] = 2] = "external_info";
    DataType[DataType["reserved"] = 3] = "reserved";
})(DataType || (DataType = {}));
var Structure = (function () {
    function Structure() {
    }
    Structure.parseTagFlags = function (flags) {
        return {
            containsHeader: Structure.isBitSet(flags, 31),
            containsFooter: Structure.isBitSet(flags, 30),
            isHeader: Structure.isBitSet(flags, 31),
            readOnly: Structure.isBitSet(flags, 0),
            dataType: (flags & 6) >> 1
        };
    };
    /**
     * @param num {number}
     * @param bit 0 is least significant bit (LSB)
     * @return {boolean} true if bit is 1; otherwise false
     */
    Structure.isBitSet = function (num, bit) {
        return (num & 1 << bit) !== 0;
    };
    /**
     * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum
     */
    Structure.DescriptorParser = {
        len: 52,
        get: function (buf, off) {
            return {
                // should equal 'MAC '
                ID: new strtok.StringType(4, 'ascii').get(buf, off),
                // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)
                version: strtok.UINT32_LE.get(buf, off + 4) / 1000,
                // the number of descriptor bytes (allows later expansion of this header)
                descriptorBytes: strtok.UINT32_LE.get(buf, off + 8),
                // the number of header APE_HEADER bytes
                headerBytes: strtok.UINT32_LE.get(buf, off + 12),
                // the number of header APE_HEADER bytes
                seekTableBytes: strtok.UINT32_LE.get(buf, off + 16),
                // the number of header data bytes (from original file)
                headerDataBytes: strtok.UINT32_LE.get(buf, off + 20),
                // the number of bytes of APE frame data
                apeFrameDataBytes: strtok.UINT32_LE.get(buf, off + 24),
                // the high order number of APE frame data bytes
                apeFrameDataBytesHigh: strtok.UINT32_LE.get(buf, off + 28),
                // the terminating data of the file (not including tag data)
                terminatingDataBytes: strtok.UINT32_LE.get(buf, off + 32),
                // the MD5 hash of the file (see notes for usage... it's a littly tricky)
                fileMD5: new strtok.BufferType(16).get(buf, off + 36)
            };
        }
    };
    /**
     * APE_HEADER: describes all of the necessary information about the APE file
     */
    Structure.Header = {
        len: 24,
        get: function (buf, off) {
            return {
                // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)
                compressionLevel: strtok.UINT16_LE.get(buf, off),
                // any format flags (for future use)
                formatFlags: strtok.UINT16_LE.get(buf, off + 2),
                // the number of audio blocks in one frame
                blocksPerFrame: strtok.UINT32_LE.get(buf, off + 4),
                // the number of audio blocks in the final frame
                finalFrameBlocks: strtok.UINT32_LE.get(buf, off + 8),
                // the total number of frames
                totalFrames: strtok.UINT32_LE.get(buf, off + 12),
                // the bits per sample (typically 16)
                bitsPerSample: strtok.UINT16_LE.get(buf, off + 16),
                // the number of channels (1 or 2)
                channel: strtok.UINT16_LE.get(buf, off + 18),
                // the sample rate (typically 44100)
                sampleRate: strtok.UINT32_LE.get(buf, off + 20)
            };
        }
    };
    /**
     * TAG: describes all the properties of the file [optional]
     */
    Structure.TagFooter = {
        len: 32,
        get: function (buf, off) {
            return {
                // should equal 'APETAGEX'
                ID: new strtok.StringType(8, 'ascii').get(buf, off),
                // equals CURRENT_APE_TAG_VERSION
                version: strtok.UINT32_LE.get(buf, off + 8),
                // the complete size of the tag, including this footer (excludes header)
                size: strtok.UINT32_LE.get(buf, off + 12),
                // the number of fields in the tag
                fields: strtok.UINT32_LE.get(buf, off + 16),
                // reserved for later use (must be zero)
                reserved: new strtok.BufferType(12).get(buf, off + 20) // ToDo: what is this???
            };
        }
    };
    Structure.TagField = function (footer) {
        return new strtok.BufferType(footer.size - Structure.TagFooter.len);
    };
    return Structure;
}());
var ApeParser = (function () {
    function ApeParser() {
        this.type = 'APEv2'; // ToDo: versionIndex should be made dynamic, APE may also contain ID3
        this.ape = {};
    }
    ApeParser.getInstance = function () {
        return new ApeParser();
    };
    /**
     * Calculate the media file duration
     * @param ah ApeHeader
     * @return {number} duration in seconds
     */
    ApeParser.calculateDuration = function (ah) {
        var duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;
        duration += ah.finalFrameBlocks;
        return duration / ah.sampleRate;
    };
    ApeParser.prototype.parse = function (stream, callback, done, readDuration, fileSize) {
        var _this = this;
        strtok.parse(stream, function (v, cb) {
            if (v === undefined) {
                cb.state = 'descriptor';
                return Structure.DescriptorParser;
            }
            switch (cb.state) {
                case 'descriptor':
                    if (v.ID !== 'MAC ') {
                        throw new Error('Expected MAC on beginning of file'); // ToDo: strip/parse JUNK
                    }
                    _this.ape.descriptor = v;
                    var lenExp = v.descriptorBytes - Structure.DescriptorParser.len;
                    if (lenExp > 0) {
                        cb.state = 'descriptorExpansion';
                        return new strtok.IgnoreType(lenExp);
                    }
                    else {
                        cb.state = 'header';
                        return Structure.Header;
                    }
                case 'descriptorExpansion':
                    cb.state = 'header';
                    return Structure.Header;
                case 'header':
                    _this.ape.header = v;
                    callback('format', 'dataformat', 'ape');
                    callback('format', 'lossless', true);
                    callback('format', 'headerType', _this.type);
                    callback('format', 'bitsPerSample', v.bitsPerSample);
                    callback('format', 'sampleRate', v.sampleRate);
                    callback('format', 'numberOfChannels', v.channel);
                    callback('format', 'duration', ApeParser.calculateDuration(v));
                    var forwardBytes = _this.ape.descriptor.seekTableBytes + _this.ape.descriptor.headerDataBytes +
                        _this.ape.descriptor.apeFrameDataBytes + _this.ape.descriptor.terminatingDataBytes;
                    cb.state = 'skipData';
                    return new strtok.IgnoreType(forwardBytes);
                case 'skipData':
                    cb.state = 'tagFooter';
                    return Structure.TagFooter;
                case 'tagFooter':
                    if (v.ID !== 'APETAGEX') {
                        done(new Error('Expected footer to start with APETAGEX '));
                    }
                    _this.ape.footer = v;
                    cb.state = 'tagField';
                    return Structure.TagField(v);
                case 'tagField':
                    _this.parseTags(_this.ape.footer, v, callback);
                    done();
                    break;
                default:
                    done(new Error('Illegal state: ' + cb.state));
            }
            return 0;
        });
    };
    ;
    ApeParser.prototype.parseTags = function (footer, buffer, callback) {
        var offset = 0;
        for (var i = 0; i < footer.fields; i++) {
            var size = strtok.UINT32_LE.get(buffer, offset);
            offset += 4;
            var flags = Structure.parseTagFlags(strtok.UINT32_LE.get(buffer, offset));
            offset += 4;
            var zero = common_1.default.findZero(buffer, offset, buffer.length);
            var key = buffer.toString('ascii', offset, zero);
            offset = zero + 1;
            switch (flags.dataType) {
                case DataType.text_utf8:
                    {
                        var value = buffer.toString('utf8', offset, offset += size);
                        var values = value.split(/\x00/g);
                        /*jshint loopfunc:true */
                        for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                            var val = values_1[_i];
                            callback(this.type, key, val);
                        }
                    }
                    break;
                case DataType.binary:
                    {
                        if (key === 'Cover Art (Front)' || key === 'Cover Art (Back)') {
                            var picData = buffer.slice(offset, offset + size);
                            var off = 0;
                            zero = common_1.default.findZero(picData, off, picData.length);
                            var description = picData.toString('utf8', off, zero);
                            off = zero + 1;
                            var picture = {
                                description: description,
                                data: new Buffer(picData.slice(off))
                            };
                            offset += size;
                            callback(this.type, key, picture);
                        }
                    }
                    break;
                default:
                    throw new Error('Unexpected data-type: ' + flags.dataType);
            }
        }
    };
    return ApeParser;
}());
module.exports = ApeParser.getInstance();
//# sourceMappingURL=monkeysaudio.js.map