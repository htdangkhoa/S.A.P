{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"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","sourcesContent":["/* jshint maxlen: 300 */\r\n'use strict';\r\nimport * as events from 'events';\r\nimport * as fs from 'fs';\r\nimport * as strtok from 'strtok2';\r\nimport * as through from 'through';\r\nimport common from './common';\r\nimport {IStreamParser} from './parser';\r\nimport TagMap from './tagmap';\r\nimport {HeaderType} from './tagmap';\r\nimport EventEmitter = NodeJS.EventEmitter;\r\nimport {ReadStream} from 'fs';\r\nimport ReadableStream = NodeJS.ReadableStream;\r\n\r\nexport interface IPicture {\r\n  format: string,\r\n  data: Uint8Array;\r\n}\r\n\r\nexport interface ICommonTagsResult {\r\n  track: { no: number, of: number },\r\n  disk: { no: number, of: number },\r\n  year?: number,\r\n  title?: string,\r\n  artist?: string, // ToDo: string[] is only used internal\r\n  artists?: string[],\r\n  albumartist?: string,\r\n  album?: string,\r\n  date?: string,\r\n  originaldate?: string,\r\n  originalyear?: number,\r\n  comment?: string,\r\n  genre?: string[];\r\n  picture?: IPicture[];\r\n  composer?: string[];\r\n  lyrics?: string[],\r\n  albumsort?: string,\r\n  titlesort?: string,\r\n  work?: string,\r\n  artistsort?: string,\r\n  albumartistsort?: string,\r\n  composersort?: string[],\r\n  lyricist?: string[],\r\n  writer?: string[],\r\n  conductor?: string[],\r\n  remixer?: string[],\r\n  arranger?: string[],\r\n  engineer?: string[],\r\n  producer?: string[],\r\n  djmixer?: string[],\r\n  mixer?: string[],\r\n  label?: string,\r\n  grouping?: string[],\r\n  subtitle?: string[],\r\n  discsubtitle?: string[],\r\n  totaltracks?: string,\r\n  totaldiscs?: string,\r\n  compilation?: string,\r\n  _rating?: string,\r\n  bpm?: string,\r\n  mood?: string,\r\n  media?: string,\r\n  catalognumber?: string,\r\n  show?: string,\r\n  showsort?: string,\r\n  podcast?: string,\r\n  podcasturl?: string,\r\n  releasestatus?: string,\r\n  releasetype?: string[],\r\n  releasecountry?: string,\r\n  script?: string,\r\n  language?: string,\r\n  copyright?: string,\r\n  license?: string,\r\n  encodedby?: string,\r\n  encodersettings?: string,\r\n  gapless?: string,\r\n  barcode?: string, // ToDo: multiple??\r\n  isrc?: string,\r\n  asin?: string,\r\n  musicbrainz_recordingid?: string,\r\n  musicbrainz_trackid?: string,\r\n  musicbrainz_albumid?: string,\r\n  musicbrainz_artistid?: string[],\r\n  musicbrainz_albumartistid?: string[],\r\n  musicbrainz_releasegroupid?: string,\r\n  musicbrainz_workid?: string,\r\n  musicbrainz_trmid?: string,\r\n  musicbrainz_discid?: string,\r\n  acoustid_id?: string,\r\n  acoustid_fingerprint?: string,\r\n  musicip_puid?: string,\r\n  musicip_fingerprint?: string,\r\n  website?: string,\r\n  'performer:instrument'?: string[],\r\n  averageLevel?: number,\r\n  peakLevel?: number;\r\n}\r\n\r\nexport interface IFormat {\r\n\r\n  dataformat?: string, // ToDo: make mandatory\r\n\r\n  type?: HeaderType, // ToDo: make mandatory\r\n\r\n  /**\r\n   * Duration in seconds\r\n   */\r\n  duration?: number,\r\n\r\n  /**\r\n   * Number bits per second of encoded audio file\r\n   */\r\n  bitrate?: number,\r\n\r\n  /**\r\n   * Sampling rate in Samples per second (S/s)\r\n   */\r\n  sampleRate?: number,\r\n\r\n  /**\r\n   * Audio bit depth\r\n   */\r\n  bitsPerSample?: number,\r\n\r\n  /**\r\n   * Encoder name, e.g.:\r\n   */\r\n  encoder?: string,\r\n\r\n  /**\r\n   * Codec profile\r\n   */\r\n  codecProfile?: string,\r\n\r\n  lossless?: boolean,\r\n\r\n  /**\r\n   * Number of audio channels\r\n   */\r\n  numberOfChannels?: number,\r\n}\r\n\r\nexport interface IResult {\r\n  common: ICommonTagsResult,\r\n  format: IFormat;\r\n}\r\n\r\nexport interface ICallbackType { (error?: Error, result?: IResult): void;\r\n}\r\n\r\nexport interface IOptions {\r\n  path?: string,\r\n  fileSize?: string,\r\n  native?: boolean,\r\n  duration?: boolean;\r\n}\r\n\r\nexport interface IFileSize {\r\n  fileSize?: ( {(size: number): void} );\r\n}\r\n\r\nclass MusicMetadataParser {\r\n\r\n  public static getInstance(): MusicMetadataParser {\r\n    return new MusicMetadataParser();\r\n  }\r\n\r\n  private static headerTypes = [\r\n    {\r\n      buf: common.asfGuidBuf,\r\n      tag: require('./asf')\r\n    },\r\n    {\r\n      buf: new Buffer('ID3'),\r\n      tag: require('./id3v2')\r\n    },\r\n    {\r\n      buf: new Buffer('ftypM4A'),\r\n      tag: require('./id4'),\r\n      offset: 4\r\n    },\r\n    {\r\n      buf: new Buffer('ftypmp42'),\r\n      tag: require('./id4'),\r\n      offset: 4\r\n    },\r\n    {\r\n      buf: new Buffer('OggS'),\r\n      tag: require('./ogg')\r\n    },\r\n    {\r\n      buf: new Buffer('fLaC'),\r\n      tag: require('./flac')\r\n    },\r\n    {\r\n      buf: new Buffer('MAC'),\r\n      tag: require('./monkeysaudio')\r\n    }\r\n  ];\r\n\r\n  private static toIntOrNull(str: string): number {\r\n    let cleaned = parseInt(str, 10);\r\n    return isNaN(cleaned) ? null : cleaned;\r\n  }\r\n\r\n  private tagMap = new TagMap();\r\n\r\n  /**\r\n   * @param stream\r\n   * @param opts\r\n   *   .filesize=true  Return filesize\r\n   *   .native=true    Will return original header in result\r\n   * @param callback\r\n   * @returns {EventEmitter}\r\n   */\r\n  public parse(stream: ReadableStream, opts: IOptions, callback: ICallbackType): EventEmitter {\r\n    if (typeof opts === 'function') {\r\n      callback = (<ICallbackType> opts);\r\n      opts = {};\r\n    }\r\n\r\n    let emitter = new events.EventEmitter();\r\n\r\n    let fsize = (cb) => {\r\n      if (opts.fileSize) {\r\n        process.nextTick(() => {\r\n          cb(opts.fileSize);\r\n        });\r\n      } else if ((<ReadStream> stream).path) {\r\n        fs.stat((<ReadStream> stream).path, (err, stats) => {\r\n          if (err) throw err;\r\n          cb(stats.size);\r\n        });\r\n      } else if ((<IFileSize> stream).fileSize) {\r\n        (<IFileSize> stream).fileSize(cb);\r\n      } else if (opts.duration) {\r\n        emitter.emit('done', new Error('for non file streams, specify the size of the stream with a fileSize option'));\r\n      }\r\n    };\r\n\r\n    // pipe to an internal stream so we aren't messing\r\n    // with the stream passed to us by our users\r\n    let istream = stream.pipe(through(null, null, {autoDestroy: false}));\r\n\r\n    /**\r\n     * Default present metadata properties\r\n     */\r\n    let metadata: IResult = {\r\n      common: {\r\n        artists: [],\r\n        track: {no: null, of: null},\r\n        disk: {no: null, of: null}\r\n      },\r\n      format: {\r\n        duration: null\r\n      }\r\n    };\r\n\r\n    let isDone = false;\r\n    let hasReadData = false;\r\n    let streamParser: IStreamParser;\r\n    let self = this;\r\n\r\n    // ToDo: expose warnings to API\r\n    let warning: string[] = [];\r\n\r\n    function tagCallback(headerType, tag, value) {\r\n      if (value === null) {\r\n        warning.push('tag ' + tag + ' is null');\r\n        return\r\n      }\r\n\r\n      if (value === '') {\r\n        warning.push('tag ' + tag + ' is empty');\r\n        return\r\n      }\r\n\r\n\r\n      if (headerType === 'format') {\r\n        metadata.format[tag] = value;\r\n      } else {\r\n        self.setCommonTags(metadata.common, <HeaderType> headerType, tag, value);\r\n      }\r\n\r\n      // Send native event, unless it's native name is the same as a common name\r\n      if (!TagMap.isCommonTag(tag)) {\r\n        emitter.emit(tag, value);\r\n      }\r\n\r\n      if (opts.native) {\r\n        if (!metadata.hasOwnProperty(headerType)) {\r\n          metadata[headerType] = {}; // Register new native header headerType\r\n        }\r\n\r\n        if (self.tagMap.isNativeSingleton(headerType, tag)) {\r\n          metadata[headerType][tag] = value;\r\n        } else {\r\n          (metadata[headerType][tag] = metadata[headerType][tag] ? metadata[headerType][tag] : []).push(value);\r\n        }\r\n      }\r\n    }\r\n\r\n    istream.once('data', (result) => {\r\n      hasReadData = true;\r\n      streamParser = common.getParserForMediaType(MusicMetadataParser.headerTypes, result);\r\n      streamParser.parse(istream, (headerType, tag, value) => {\r\n        tagCallback(headerType, tag, value);\r\n      }, done, opts.duration, fsize);\r\n      // re-emitting the first data chunk so the\r\n      // parser picks the stream up from the start\r\n      istream.emit('data', result);\r\n    });\r\n\r\n    istream.once('end', () => {\r\n      if (!hasReadData) {\r\n        done(new Error('Could not read any data from this stream'));\r\n      } else {\r\n        if (!isDone) {\r\n          isDone = true;\r\n          // Ensure the parsers 'end' handlers is executed first\r\n          if (streamParser && streamParser.end) {\r\n            streamParser.end(tagCallback, done);\r\n          } else done();\r\n        }\r\n      }\r\n\r\n    });\r\n\r\n    istream.on('close', onClose);\r\n\r\n    function onClose() {\r\n      done(new Error('Unexpected end of stream'));\r\n    }\r\n\r\n    function done(err?: Error) {\r\n      isDone = true;\r\n      istream.removeListener('close', onClose);\r\n\r\n      if(!err) {\r\n        /**\r\n         * If MusicBrainz defined artists, the artist may be a single combined field,\r\n         * otherwise artist may contain multiple artists.\r\n         */\r\n        if (metadata.common.artists && metadata.common.artists.length > 0) {\r\n          metadata.common.artist = metadata.common.artist[0];\r\n        } else {\r\n          if (metadata.common.artist) {\r\n            metadata.common.artists = <any> metadata.common.artist;\r\n            if (metadata.common.artist.length > 1) {\r\n              delete metadata.common.artist;\r\n            } else {\r\n              metadata.common.artist = metadata.common.artist[0];\r\n            }\r\n          }\r\n        }\r\n\r\n        // We only emit aliased events once the 'done' event has been raised,\r\n        // this is because an alias like 'artist' could have values split\r\n        // over many data chunks.\r\n        for (let _alias in metadata.common) {\r\n          if (metadata.common.hasOwnProperty(_alias)) {\r\n            emitter.emit(_alias, metadata.common[_alias]);\r\n          }\r\n        }\r\n      }\r\n\r\n      if (callback) {\r\n        callback(err, metadata);\r\n      }\r\n      return strtok.DONE;\r\n    }\r\n\r\n    return emitter;\r\n  }\r\n\r\n  /**\r\n   * Process and set common tags\r\n   * @param comTags Target metadata to wrote common tags to\r\n   * @param type    Native headerType e.g.: 'm4a' | 'asf' | 'id3v1.1' | 'id3v2.4' | 'vorbis'\r\n   * @param tag     Native tag\r\n   * @param value   Native tag value\r\n   */\r\n  private setCommonTags(comTags, type: HeaderType, tag: string, value: any) {\r\n\r\n    switch (type) {\r\n      /*\r\n       case 'vorbis':\r\n       switch (tag) {\r\n\r\n       case 'TRACKTOTAL':\r\n       case 'TOTALTRACKS': // rare tag\r\n       comTags.track.of = MusicMetadataParser.toIntOrNull(value)\r\n       return\r\n\r\n       case 'DISCTOTAL':\r\n       case 'TOTALDISCS': // rare tag\r\n       comTags.disk.of = MusicMetadataParser.toIntOrNull(value)\r\n       return\r\n       default:\r\n       }\r\n       break\r\n       */\r\n\r\n      case 'id3v2.3':\r\n      case 'id3v2.4':\r\n        switch (tag) {\r\n\r\n          /*\r\n           case 'TXXX':\r\n           tag += ':' + value.description\r\n           value = value.text\r\n           break*/\r\n\r\n          case 'UFID': // decode MusicBrainz Recording Id\r\n            if (value.owner_identifier === 'http://musicbrainz.org') {\r\n              tag += ':' + value.owner_identifier;\r\n              value = common.decodeString(value.identifier, 'iso-8859-1');\r\n            }\r\n            break;\r\n\r\n          case 'PRIV':\r\n            switch (value.owner_identifier) {\r\n              // decode Windows Media Player\r\n              case 'AverageLevel':\r\n              case 'PeakValue':\r\n                tag += ':' + value.owner_identifier;\r\n                value = common.strtokUINT32_LE.get(value.data, 0);\r\n                break;\r\n              default:\r\n              // Unknown PRIV owner-identifier\r\n            }\r\n            break;\r\n\r\n          default:\r\n          // nothing to do\r\n        }\r\n        break;\r\n      default:\r\n      // nothing to do\r\n    }\r\n\r\n    // Convert native tag event to common (aliased) event\r\n    let alias = this.tagMap.getCommonName(type, tag);\r\n\r\n    if (alias) {\r\n      // Common tag (alias) found\r\n\r\n      // check if we need to do something special with common tag\r\n      // if the event has been aliased then we need to clean it before\r\n      // it is emitted to the user. e.g. genre (20) -> Electronic\r\n      switch (alias) {\r\n        case 'genre':\r\n          value = common.parseGenre(value);\r\n          break;\r\n\r\n        case 'picture':\r\n          value = this.cleanupPicture(value);\r\n          break;\r\n\r\n        case 'totaltracks':\r\n          comTags.track.of = MusicMetadataParser.toIntOrNull(value);\r\n          return;\r\n\r\n        case 'totaldiscs':\r\n          comTags.disk.of = MusicMetadataParser.toIntOrNull(value);\r\n          return;\r\n\r\n        case 'track':\r\n        case 'disk':\r\n          let of = comTags[alias].of; // store of value, maybe maybe overwritten\r\n          comTags[alias] = this.cleanupTrack(value);\r\n          comTags[alias].of = of != null ? of : comTags[alias].of;\r\n          return;\r\n\r\n        case 'year':\r\n        case 'originalyear':\r\n          value = parseInt(value, 10);\r\n          break;\r\n\r\n        case 'date':\r\n          // ToDo: be more strict on 'YYYY...'\r\n          // if (/^\\d{4}\\-(0?[1-9]|1[012])\\-(0?[1-9]|[12][0-9]|3[01])$/.test(value)) {\r\n          comTags.year = parseInt(value.substr(0, 4), 10);\r\n          break;\r\n\r\n        default:\r\n        // nothing to do\r\n      }\r\n\r\n      if (alias !== 'artist' && TagMap.isSingleton(alias)) {\r\n        comTags[alias] = value;\r\n      } else {\r\n        if (comTags.hasOwnProperty(alias)) {\r\n          comTags[alias].push(value);\r\n        } else {\r\n          // if we haven't previously seen this tag then\r\n          // initialize it to an array, ready for values to be entered\r\n          comTags[alias] = [value];\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // TODO: a string of 1of1 would fail to be converted\r\n  // converts 1/10 to no : 1, of : 10\r\n  // or 1 to no : 1, of : 0\r\n  private cleanupTrack(origVal: number | string) {\r\n    let split = origVal.toString().split('/');\r\n    return {\r\n      no: parseInt(split[0], 10) || null,\r\n      of: parseInt(split[1], 10) || null\r\n    };\r\n  }\r\n\r\n  private cleanupPicture(picture) {\r\n    let newFormat;\r\n    if (picture.format) {\r\n      let split = picture.format.toLowerCase().split('/');\r\n      newFormat = (split.length > 1) ? split[1] : split[0];\r\n      if (newFormat === 'jpeg') newFormat = 'jpg';\r\n    } else {\r\n      newFormat = 'jpg';\r\n    }\r\n    return {format: newFormat, data: picture.data};\r\n  }\r\n}\r\n\r\n/**\r\n * Parse audio stream\r\n * @param stream\r\n * @param opts\r\n *   .filesize=true  Return filesize\r\n *   .native=true    Will return original header in result\r\n * @param callback\r\n * @returns {*|EventEmitter}\r\n */\r\nexport function parseStream(stream: ReadableStream, opts: IOptions, callback: ICallbackType) {\r\n  return MusicMetadataParser.getInstance().parse(stream, opts, callback);\r\n}\r\n"]}