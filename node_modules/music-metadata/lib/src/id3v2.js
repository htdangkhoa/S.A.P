"use strict";
var strtok = require('strtok2');
var util_1 = require('util');
var common_1 = require('./common');
var id3v2_frames_1 = require('./id3v2_frames');
var mpeg_1 = require('./mpeg');
var State;
(function (State) {
    State[State["header"] = 0] = "header";
    State[State["extendedHeader"] = 1] = "extendedHeader";
    State[State["extendedHeaderData"] = 2] = "extendedHeaderData";
    State[State["id3_data"] = 3] = "id3_data";
    State[State["MP3"] = 4] = "MP3";
})(State || (State = {}));
var ID3v2 = (function () {
    function ID3v2() {
    }
    /**
     * 28 bits (representing up to 256MB) integer, the msb is 0 to avoid 'false syncsignals'.
     * 4 * %0xxxxxxx
     */
    ID3v2.UINT32SYNCSAFE = {
        get: function (buf, off) {
            return buf[off + 3] & 0x7f | ((buf[off + 2]) << 7) |
                ((buf[off + 1]) << 14) | ((buf[off]) << 21);
        },
        len: 4
    };
    /**
     * ID3v2 header
     * Ref: http://id3.org/id3v2.3.0#ID3v2_header
     * ToDo
     */
    ID3v2.Header = {
        len: 10,
        get: function (buf, off) {
            return {
                // ID3v2/file identifier   "ID3"
                fileIdentifier: new strtok.StringType(3, 'ascii').get(buf, off),
                // ID3v2 versionIndex
                version: {
                    major: strtok.INT8.get(buf, off + 3),
                    revision: strtok.INT8.get(buf, off + 4)
                },
                // ID3v2 flags
                flags: {
                    // Raw flags value
                    raw: strtok.INT8.get(buf, off + 4),
                    // Unsynchronisation
                    unsynchronisation: common_1.default.strtokBITSET.get(buf, off + 5, 7),
                    // Extended header
                    isExtendedHeader: common_1.default.strtokBITSET.get(buf, off + 5, 6),
                    // Experimental indicator
                    expIndicator: common_1.default.strtokBITSET.get(buf, off + 5, 5),
                    footer: common_1.default.strtokBITSET.get(buf, off + 5, 4)
                },
                size: ID3v2.UINT32SYNCSAFE.get(buf, off + 6)
            };
        }
    };
    ID3v2.ExtendedHeader = {
        len: 10,
        get: function (buf, off) {
            return {
                // Extended header size
                size: strtok.UINT32_BE.get(buf, off),
                // Extended Flags
                extendedFlags: strtok.UINT16_BE.get(buf, off + 4),
                // Size of padding
                sizeOfPadding: strtok.UINT32_BE.get(buf, off + 6),
                // CRC data present
                crcDataPresent: common_1.default.strtokBITSET.get(buf, off + 4, 31)
            };
        }
    };
    return ID3v2;
}());
var Id3v2Parser = (function () {
    function Id3v2Parser() {
        this.state = State.header;
    }
    Id3v2Parser.getInstance = function () {
        return new Id3v2Parser();
    };
    Id3v2Parser.readFrameHeader = function (v, majorVer) {
        var header;
        switch (majorVer) {
            case 2:
                header = {
                    id: v.toString('ascii', 0, 3),
                    length: common_1.default.strtokUINT24_BE.get(v, 3)
                };
                break;
            case 3:
                header = {
                    id: v.toString('ascii', 0, 4),
                    length: strtok.UINT32_BE.get(v, 4),
                    flags: Id3v2Parser.readFrameFlags(v.slice(8, 10))
                };
                break;
            case 4:
                header = {
                    id: v.toString('ascii', 0, 4),
                    length: ID3v2.UINT32SYNCSAFE.get(v, 4),
                    flags: Id3v2Parser.readFrameFlags(v.slice(8, 10))
                };
                break;
            default:
                throw new Error('Unexpected majorVer: ' + majorVer);
        }
        return header;
    };
    Id3v2Parser.getFrameHeaderLength = function (majorVer, done) {
        switch (majorVer) {
            case 2:
                return 6;
            case 3:
            case 4:
                return 10;
            default:
                return done(new Error('header versionIndex is incorrect'));
        }
    };
    Id3v2Parser.readFrameFlags = function (b) {
        return {
            status: {
                tag_alter_preservation: common_1.default.strtokBITSET.get(b, 0, 6),
                file_alter_preservation: common_1.default.strtokBITSET.get(b, 0, 5),
                read_only: common_1.default.strtokBITSET.get(b, 0, 4)
            },
            format: {
                grouping_identity: common_1.default.strtokBITSET.get(b, 1, 7),
                compression: common_1.default.strtokBITSET.get(b, 1, 3),
                encryption: common_1.default.strtokBITSET.get(b, 1, 2),
                unsynchronisation: common_1.default.strtokBITSET.get(b, 1, 1),
                data_length_indicator: common_1.default.strtokBITSET.get(b, 1, 0)
            }
        };
    };
    Id3v2Parser.prototype.parse = function (stream, callback, done, readDuration, fileSize) {
        var _this = this;
        var self = this;
        var id3Header;
        var extendedHeader;
        var headerType;
        strtok.parse(stream, function (v, cb) {
            if (v === undefined) {
                self.state = State.header;
                return ID3v2.Header;
            }
            switch (self.state) {
                case State.header:
                    id3Header = v;
                    if (id3Header.fileIdentifier !== 'ID3') {
                        return done(new Error('expected file identifier \'ID3\' not found'));
                    }
                    headerType = ('id3v2.' + id3Header.version.major);
                    if (id3Header.flags.isExtendedHeader) {
                        self.state = State.extendedHeader;
                        return ID3v2.ExtendedHeader;
                    }
                    else {
                        self.state = State.id3_data;
                        return new strtok.BufferType(id3Header.size);
                    }
                case State.extendedHeader:
                    extendedHeader = v;
                    var dataRemaining = extendedHeader.size - ID3v2.ExtendedHeader.len;
                    if (dataRemaining > 0) {
                        self.state = State.extendedHeaderData;
                        return new strtok.BufferType(dataRemaining);
                    }
                    else {
                        self.state = State.id3_data;
                        return new strtok.BufferType(id3Header.size - extendedHeader.size);
                    }
                case State.extendedHeaderData:
                    self.state = State.id3_data;
                    return new strtok.BufferType(id3Header.size - extendedHeader.size);
                case State.id3_data:
                    for (var _i = 0, _a = _this.parseMetadata(v, id3Header, done); _i < _a.length; _i++) {
                        var tag = _a[_i];
                        if (tag.id === 'TXXX') {
                            for (var _b = 0, _c = tag.value.text; _b < _c.length; _b++) {
                                var text = _c[_b];
                                callback(headerType, tag.id + ':' + tag.value.description, text);
                            }
                        }
                        else if (util_1.isArray(tag.value)) {
                            for (var _d = 0, _e = tag.value; _d < _e.length; _d++) {
                                var value = _e[_d];
                                callback(headerType, tag.id, value);
                            }
                        }
                        else {
                            callback(headerType, tag.id, tag.value);
                        }
                    }
                    callback('format', 'headerType', headerType);
                    _this.mpegParser = new mpeg_1.MpegParser(id3Header.size);
                    _this.mpegParser.parse(stream, callback, done, readDuration, fileSize);
                    return strtok.DONE;
                default:
                    done(new Error('Undefined state: ' + self.state));
            }
        });
    };
    Id3v2Parser.prototype.end = function (callback, done) {
        this.mpegParser.end(callback, done);
    };
    Id3v2Parser.prototype.parseMetadata = function (data, header, done) {
        var offset = 0;
        var tags = [];
        while (true) {
            if (offset === data.length)
                break;
            var frameHeaderBytes = data.slice(offset, offset += Id3v2Parser.getFrameHeaderLength(header.version.major, done));
            var frameHeader = Id3v2Parser.readFrameHeader(frameHeaderBytes, header.version.major);
            // Last frame. Check first char is a letter, bit of defensive programming
            if (frameHeader.id === '' || frameHeader.id === '\u0000\u0000\u0000\u0000' ||
                'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(frameHeader.id[0]) === -1) {
                // ToDo: generate warning
                break;
            }
            var frameDataBytes = data.slice(offset, offset += frameHeader.length);
            var values = this.readFrameData(frameDataBytes, frameHeader, header.version.major);
            tags.push({ id: frameHeader.id, value: values });
        }
        return tags;
    };
    Id3v2Parser.prototype.readFrameData = function (v, frameHeader, majorVer) {
        switch (majorVer) {
            case 2:
                return id3v2_frames_1.default.readData(v, frameHeader.id, null, majorVer);
            case 3:
            case 4:
                if (frameHeader.flags.format.unsynchronisation) {
                    v = common_1.default.removeUnsyncBytes(v);
                }
                if (frameHeader.flags.format.data_length_indicator) {
                    v = v.slice(4, v.length);
                }
                return id3v2_frames_1.default.readData(v, frameHeader.id, frameHeader.flags, majorVer);
            default:
                throw new Error('Unexpected majorVer: ' + majorVer);
        }
    };
    return Id3v2Parser;
}());
module.exports = Id3v2Parser.getInstance();
//# sourceMappingURL=id3v2.js.map