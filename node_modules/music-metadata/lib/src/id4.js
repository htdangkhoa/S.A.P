"use strict";
var strtok = require('strtok2');
var common_1 = require('./common');
var State;
(function (State) {
    State[State["skip"] = -1] = "skip";
    State[State["atomLength"] = 0] = "atomLength";
    State[State["atomName"] = 1] = "atomName";
    State[State["ilstAtom"] = 2] = "ilstAtom";
    State[State["mdhdAtom"] = 3] = "mdhdAtom";
})(State || (State = {}));
var Id4Parser = (function () {
    function Id4Parser() {
    }
    Id4Parser.getInstance = function () {
        return new Id4Parser();
    };
    Id4Parser.prototype.parse = function (stream, callback, done, readDuration, fileSize) {
        var _this = this;
        strtok.parse(stream, function (v, cb) {
            // the very first thing we expect to see is the first atom's length
            if (!v) {
                cb.metaAtomsTotalLength = 0;
                cb.state = 0;
                return strtok.UINT32_BE;
            }
            switch (cb.state) {
                case State.skip:
                    cb.state = State.atomLength;
                    return strtok.UINT32_BE;
                case State.atomLength:
                    cb.atomLength = v;
                    cb.state++;
                    return new strtok.BufferType(4);
                case State.atomName:
                    v = v.toString('binary');
                    cb.atomName = v;
                    // meta has 4 bytes padding at the start (skip)
                    if (v === 'meta') {
                        cb.state = State.skip;
                        return new strtok.IgnoreType(4);
                    }
                    if (readDuration) {
                        if (v === 'mdhd') {
                            cb.state = State.mdhdAtom;
                            return new strtok.BufferType(cb.atomLength - 8);
                        }
                    }
                    if (!~Id4Parser.ContainerAtoms.indexOf(v)) {
                        if (cb.atomContainer === 'ilst') {
                            cb.state = State.ilstAtom;
                            return new strtok.BufferType(cb.atomLength - 8);
                        }
                        cb.state = State.skip;
                        return new strtok.IgnoreType(cb.atomLength - 8);
                    }
                    // dig into container atoms
                    cb.atomContainer = v;
                    cb.atomContainerLength = cb.atomLength;
                    cb.state--;
                    return strtok.UINT32_BE;
                case State.ilstAtom:
                    cb.metaAtomsTotalLength += cb.atomLength;
                    var results = _this.processMetaAtom(v, cb.atomName, cb.atomLength - 8);
                    if (results.length > 0) {
                        for (var _i = 0, results_1 = results; _i < results_1.length; _i++) {
                            var result = results_1[_i];
                            callback(Id4Parser.type, cb.atomName, result);
                        }
                    }
                    // we can stop processing atoms once we get to the end of the ilst atom
                    if (cb.metaAtomsTotalLength >= cb.atomContainerLength - 8) {
                        return done();
                    }
                    cb.state = State.atomLength;
                    return strtok.UINT32_BE;
                case State.mdhdAtom:
                    // TODO: support version 1
                    var sampleRate = v.readUInt32BE(12);
                    var duration = v.readUInt32BE(16);
                    callback('format', 'duration', duration / sampleRate);
                    callback('format', 'sampleRate', sampleRate); // ToDo: add to test
                    cb.state = State.atomLength;
                    return strtok.UINT32_BE;
                default:
                    return done(new Error('illegal state:' + cb.state));
            }
        });
    };
    Id4Parser.prototype.processMetaAtom = function (data, atomName, atomLength) {
        var result = [];
        var offset = 0;
        // ignore proprietary iTunes atoms (for now)
        if (atomName === '----')
            return result;
        while (offset < atomLength) {
            var length_1 = strtok.UINT32_BE.get(data, offset);
            var contType = Id4Parser.Types[strtok.UINT32_BE.get(data, offset + 8)];
            var content = this.processMetaDataAtom(data.slice(offset + 12, offset + length_1), contType, atomName);
            result.push(content);
            offset += length_1;
        }
        return result;
    };
    Id4Parser.prototype.processMetaDataAtom = function (data, type, atomName) {
        switch (type) {
            case 'text':
                return data.toString('utf8', 4);
            case 'uint8':
                if (atomName === 'gnre') {
                    var genreInt = strtok.UINT8.get(data, 5);
                    return common_1.default.GENRES[genreInt - 1];
                }
                if (atomName === 'trkn' || atomName === 'disk') {
                    return data[7] + '/' + data[9];
                }
                return strtok.UINT8.get(data, 4);
            case 'jpeg':
            case 'png':
                return {
                    format: 'image/' + type,
                    data: new Buffer(data.slice(4))
                };
            default:
                throw new Error('Unexpected type: ' + type);
        }
    };
    Id4Parser.type = 'm4a';
    Id4Parser.Types = {
        0: 'uint8',
        1: 'text',
        13: 'jpeg',
        14: 'png',
        21: 'uint8'
    };
    Id4Parser.ContainerAtoms = ['moov', 'udta', 'meta', 'ilst', 'trak', 'mdia'];
    return Id4Parser;
}());
module.exports = Id4Parser.getInstance();
//# sourceMappingURL=id4.js.map