{"version":3,"file":"monkeysaudio.js","sourceRoot":"","sources":["../../src/monkeysaudio.ts"],"names":[],"mappings":"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","sourcesContent":["'use strict';\r\n\r\nimport * as strtok from 'strtok2';\r\nimport common from './common';\r\nimport {IStreamParser, TagCallback} from './parser';\r\nimport {HeaderType} from './tagmap';\r\n\r\n/**\r\n * APETag versionIndex history / supported formats\r\n *\r\n *  1.0 (1000) - Original APE tag spec.  Fully supported by this code.\r\n *  2.0 (2000) - Refined APE tag spec (better streaming support, UTF encoding). Fully supported by this code.\r\n *\r\n *  Notes:\r\n *  - also supports reading of ID3v1.1 tags\r\n *  - all saving done in the APE Tag format using CURRENT_APE_TAG_VERSION\r\n *\r\n * APE File Format Overview: (pieces in order -- only valid for the latest versionIndex APE files)\r\n *\r\n * JUNK - any amount of \"junk\" before the APE_DESCRIPTOR (so people that put ID3v2 tags on the files aren't hosed)\r\n * APE_DESCRIPTOR - defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\r\n * APE_HEADER - describes all of the necessary information about the APE file\r\n * SEEK TABLE - the table that represents seek offsets [optional]\r\n * HEADER DATA - the pre-audio data from the original file [optional]\r\n * APE FRAMES - the actual compressed audio (broken into frames for seekability)\r\n * TERMINATING DATA - the post-audio data from the original file [optional]\r\n * TAG - describes all the properties of the file [optional]\r\n */\r\n\r\ntype Descriptor = {\r\n  // should equal 'MAC '\r\n  ID: string,\r\n  // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\r\n  version: number,\r\n  // the number of descriptor bytes (allows later expansion of this header)\r\n  descriptorBytes: number,\r\n  // the number of header APE_HEADER bytes\r\n  headerBytes: number,\r\n  // the number of header APE_HEADER bytes\r\n  seekTableBytes: number,\r\n  // the number of header data bytes (from original file)\r\n  headerDataBytes: number,\r\n  // the number of bytes of APE frame data\r\n  apeFrameDataBytes: number,\r\n  // the high order number of APE frame data bytes\r\n  apeFrameDataBytesHigh: number,\r\n  // the terminating data of the file (not including tag data)\r\n  terminatingDataBytes: number,\r\n  // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n  fileMD5: number[]\r\n};\r\n\r\n/**\r\n * APE_HEADER: describes all of the necessary information about the APE file\r\n */\r\ntype Header = {\r\n  // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\r\n  compressionLevel: number,\r\n  // any format flags (for future use)\r\n  formatFlags: number,\r\n  // the number of audio blocks in one frame\r\n  blocksPerFrame: number,\r\n  // the number of audio blocks in the final frame\r\n  finalFrameBlocks: number,\r\n  // the total number of frames\r\n  totalFrames: number,\r\n  // the bits per sample (typically 16)\r\n  bitsPerSample: number,\r\n  // the number of channels (1 or 2)\r\n  channel: number,\r\n  // the sample rate (typically 44100)\r\n  sampleRate: number\r\n};\r\n\r\ntype Footer = {\r\n  // should equal 'APETAGEX'\r\n  ID: string,\r\n  // equals CURRENT_APE_TAG_VERSION\r\n  version: number,\r\n  // the complete size of the tag, including this footer (excludes header)\r\n  size: number,\r\n  // the number of fields in the tag\r\n  fields: number,\r\n  // reserved for later use (must be zero)\r\n  reserved: number[] // ToDo: what is this???\r\n};\r\n\r\ntype TagFlags = {\r\n  containsHeader: boolean,\r\n  containsFooter: boolean,\r\n  isHeader: boolean,\r\n  readOnly: boolean,\r\n  dataType: DataType\r\n};\r\n\r\nenum DataType {\r\n  text_utf8 = 0,\r\n  binary = 1,\r\n  external_info = 2,\r\n  reserved = 3\r\n}\r\n\r\nclass Structure {\r\n  /**\r\n   * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\r\n   */\r\n  public static DescriptorParser = {\r\n    len: 52,\r\n\r\n    get: (buf, off) => {\r\n      return {\r\n        // should equal 'MAC '\r\n        ID: new strtok.StringType(4, 'ascii').get(buf, off),\r\n        // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\r\n        version: strtok.UINT32_LE.get(buf, off + 4) / 1000,\r\n        // the number of descriptor bytes (allows later expansion of this header)\r\n        descriptorBytes: strtok.UINT32_LE.get(buf, off + 8),\r\n        // the number of header APE_HEADER bytes\r\n        headerBytes: strtok.UINT32_LE.get(buf, off + 12),\r\n        // the number of header APE_HEADER bytes\r\n        seekTableBytes: strtok.UINT32_LE.get(buf, off + 16),\r\n        // the number of header data bytes (from original file)\r\n        headerDataBytes: strtok.UINT32_LE.get(buf, off + 20),\r\n        // the number of bytes of APE frame data\r\n        apeFrameDataBytes: strtok.UINT32_LE.get(buf, off + 24),\r\n        // the high order number of APE frame data bytes\r\n        apeFrameDataBytesHigh: strtok.UINT32_LE.get(buf, off + 28),\r\n        // the terminating data of the file (not including tag data)\r\n        terminatingDataBytes: strtok.UINT32_LE.get(buf, off + 32),\r\n        // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n        fileMD5: new strtok.BufferType(16).get(buf, off + 36)\r\n      };\r\n    }\r\n  };\r\n\r\n  /**\r\n   * APE_HEADER: describes all of the necessary information about the APE file\r\n   */\r\n  public static Header = {\r\n    len: 24,\r\n\r\n    get: (buf, off) => {\r\n      return {\r\n        // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\r\n        compressionLevel: strtok.UINT16_LE.get(buf, off),\r\n        // any format flags (for future use)\r\n        formatFlags: strtok.UINT16_LE.get(buf, off + 2),\r\n        // the number of audio blocks in one frame\r\n        blocksPerFrame: strtok.UINT32_LE.get(buf, off + 4),\r\n        // the number of audio blocks in the final frame\r\n        finalFrameBlocks: strtok.UINT32_LE.get(buf, off + 8),\r\n        // the total number of frames\r\n        totalFrames: strtok.UINT32_LE.get(buf, off + 12),\r\n        // the bits per sample (typically 16)\r\n        bitsPerSample: strtok.UINT16_LE.get(buf, off + 16),\r\n        // the number of channels (1 or 2)\r\n        channel: strtok.UINT16_LE.get(buf, off + 18),\r\n        // the sample rate (typically 44100)\r\n        sampleRate: strtok.UINT32_LE.get(buf, off + 20)\r\n      };\r\n    }\r\n  };\r\n\r\n  /**\r\n   * TAG: describes all the properties of the file [optional]\r\n   */\r\n  public static TagFooter = {\r\n    len: 32,\r\n\r\n    get: (buf, off) => {\r\n      return {\r\n        // should equal 'APETAGEX'\r\n        ID: new strtok.StringType(8, 'ascii').get(buf, off),\r\n        // equals CURRENT_APE_TAG_VERSION\r\n        version: strtok.UINT32_LE.get(buf, off + 8),\r\n        // the complete size of the tag, including this footer (excludes header)\r\n        size: strtok.UINT32_LE.get(buf, off + 12),\r\n        // the number of fields in the tag\r\n        fields: strtok.UINT32_LE.get(buf, off + 16),\r\n        // reserved for later use (must be zero)\r\n        reserved: new strtok.BufferType(12).get(buf, off + 20) // ToDo: what is this???\r\n      };\r\n    }\r\n  };\r\n\r\n  public static TagField = (footer) => {\r\n    return new strtok.BufferType(footer.size - Structure.TagFooter.len);\r\n  }\r\n\r\n  public static parseTagFlags(flags): TagFlags {\r\n    return {\r\n      containsHeader: Structure.isBitSet(flags, 31),\r\n      containsFooter: Structure.isBitSet(flags, 30),\r\n      isHeader: Structure.isBitSet(flags, 31),\r\n      readOnly: Structure.isBitSet(flags, 0),\r\n      dataType: (flags & 6) >> 1\r\n    };\r\n  }\r\n\r\n  /**\r\n   * @param num {number}\r\n   * @param bit 0 is least significant bit (LSB)\r\n   * @return {boolean} true if bit is 1; otherwise false\r\n   */\r\n  public static isBitSet(num, bit): boolean {\r\n    return (num & 1 << bit) !== 0;\r\n  }\r\n\r\n}\r\n\r\ntype ApeInfo = {\r\n  descriptor?: Descriptor,\r\n  header?: Header,\r\n  footer?: Footer\r\n};\r\n\r\nclass ApeParser implements IStreamParser {\r\n\r\n  public static getInstance(): ApeParser {\r\n    return new ApeParser();\r\n  }\r\n  /**\r\n   * Calculate the media file duration\r\n   * @param ah ApeHeader\r\n   * @return {number} duration in seconds\r\n   */\r\n  public static calculateDuration(ah: Header): number {\r\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\r\n    duration += ah.finalFrameBlocks;\r\n    return duration / ah.sampleRate;\r\n  }\r\n\r\n  private type: HeaderType = 'APEv2'; // ToDo: versionIndex should be made dynamic, APE may also contain ID3\r\n\r\n  private ape: ApeInfo = {};\r\n\r\n  public parse(stream, callback: TagCallback, done?, readDuration?, fileSize?) {\r\n\r\n    strtok.parse(stream, (v, cb) => {\r\n      if (v === undefined) {\r\n        cb.state = 'descriptor';\r\n        return Structure.DescriptorParser;\r\n      }\r\n\r\n      switch (cb.state) {\r\n        case 'descriptor':\r\n          if (v.ID !== 'MAC ') {\r\n            throw new Error('Expected MAC on beginning of file'); // ToDo: strip/parse JUNK\r\n          }\r\n          this.ape.descriptor = v;\r\n          let lenExp = v.descriptorBytes - Structure.DescriptorParser.len;\r\n          if (lenExp > 0) {\r\n            cb.state = 'descriptorExpansion';\r\n            return new strtok.IgnoreType(lenExp);\r\n          } else {\r\n            cb.state = 'header';\r\n            return Structure.Header;\r\n          }\r\n\r\n        case 'descriptorExpansion':\r\n          cb.state = 'header';\r\n          return Structure.Header;\r\n\r\n        case 'header':\r\n          this.ape.header = v;\r\n          callback('format', 'dataformat', 'ape');\r\n          callback('format', 'lossless', true);\r\n          callback('format', 'headerType', this.type);\r\n          callback('format', 'bitsPerSample', v.bitsPerSample);\r\n          callback('format', 'sampleRate', v.sampleRate);\r\n          callback('format', 'numberOfChannels', v.channel);\r\n          callback('format', 'duration', ApeParser.calculateDuration(v));\r\n          let forwardBytes = this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\r\n            this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes;\r\n          cb.state = 'skipData';\r\n          return new strtok.IgnoreType(forwardBytes);\r\n\r\n        case 'skipData':\r\n          cb.state = 'tagFooter';\r\n          return Structure.TagFooter;\r\n\r\n        case 'tagFooter':\r\n          if (v.ID !== 'APETAGEX') {\r\n            done(new Error('Expected footer to start with APETAGEX '));\r\n          }\r\n          this.ape.footer = v;\r\n          cb.state = 'tagField';\r\n          return Structure.TagField(v);\r\n\r\n        case 'tagField':\r\n          this.parseTags(this.ape.footer, v, callback);\r\n          done();\r\n          break;\r\n\r\n        default:\r\n          done(new Error('Illegal state: ' + cb.state));\r\n      }\r\n      return 0;\r\n    });\r\n  };\r\n\r\n  private parseTags(footer: Footer, buffer: Buffer, callback) {\r\n    let offset = 0;\r\n\r\n    for (let i = 0; i < footer.fields; i++) {\r\n      let size = strtok.UINT32_LE.get(buffer, offset);\r\n      offset += 4;\r\n      let flags = Structure.parseTagFlags(strtok.UINT32_LE.get(buffer, offset));\r\n      offset += 4;\r\n\r\n      let zero = common.findZero(buffer, offset, buffer.length);\r\n      let key = buffer.toString('ascii', offset, zero);\r\n      offset = zero + 1;\r\n\r\n      switch (flags.dataType) {\r\n        case DataType.text_utf8: { // utf-8 textstring\r\n          let value = buffer.toString('utf8', offset, offset += size);\r\n          let values = value.split(/\\x00/g);\r\n\r\n          /*jshint loopfunc:true */\r\n          for (let val of values) {\r\n            callback(this.type, key, val);\r\n          }\r\n        }\r\n          break;\r\n\r\n        case DataType.binary: { // binary (probably artwork)\r\n          if (key === 'Cover Art (Front)' || key === 'Cover Art (Back)') {\r\n            let picData = buffer.slice(offset, offset + size);\r\n\r\n            let off = 0;\r\n            zero = common.findZero(picData, off, picData.length);\r\n            let description = picData.toString('utf8', off, zero);\r\n            off = zero + 1;\r\n\r\n            let picture = {\r\n              description,\r\n              data: new Buffer(picData.slice(off))\r\n            };\r\n\r\n            offset += size;\r\n            callback(this.type, key, picture);\r\n          }\r\n        }\r\n          break;\r\n\r\n        default:\r\n          throw new Error('Unexpected data-type: ' + flags.dataType);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nmodule.exports = ApeParser.getInstance();\r\n"]}