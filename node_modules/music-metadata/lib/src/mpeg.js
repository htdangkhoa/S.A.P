'use strict';
var strtok = require('strtok2');
var common_1 = require('./common');
var State;
(function (State) {
    State[State["mpegSearchSync1"] = 1] = "mpegSearchSync1";
    State[State["mpegSearchSync2"] = 2] = "mpegSearchSync2";
    State[State["audio_frame_header"] = 3] = "audio_frame_header";
    State[State["CRC"] = 4] = "CRC";
    State[State["side_information"] = 5] = "side_information";
    State[State["xtra_info_header"] = 6] = "xtra_info_header";
    State[State["skip_frame_data"] = 7] = "skip_frame_data";
})(State || (State = {}));
/**
 * MPEG Audio Layer I/II/III frame header
 * Ref: https://www.mp3-tech.org/programmer/frame_header.html
 * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM
 */
var MpegFrameHeader = (function () {
    function MpegFrameHeader(buf, off) {
        // B(20,19): MPEG Audio versionIndex ID
        this.versionIndex = common_1.default.getBitAllignedNumber(buf, off + 1, 3, 2);
        // C(18,17): Layer description
        this.layer = MpegFrameHeader.LayerDescription[common_1.default.getBitAllignedNumber(buf, off + 1, 5, 2)];
        // D(16): Protection bit (if true 16-bit CRC follows header)
        this.isProtectedByCRC = !common_1.default.isBitSet(buf, off + 1, 7);
        // E(15,12): Bitrate index
        this.bitrateIndex = common_1.default.getBitAllignedNumber(buf, off + 2, 0, 4);
        // F(11,10): Sampling rate frequency index
        this.sampRateFreqIndex = common_1.default.getBitAllignedNumber(buf, off + 2, 4, 2);
        // G(9): Padding bit
        this.padding = common_1.default.isBitSet(buf, off + 2, 6);
        // H(8): Private bit
        this.privateBit = common_1.default.isBitSet(buf, off + 2, 7);
        // I(7,6): Channel Mode
        this.channelModeIndex = common_1.default.getBitAllignedNumber(buf, off + 3, 0, 2);
        // J(5,4): Mode extension (Only used in Joint stereo)
        this.modeExtension = common_1.default.getBitAllignedNumber(buf, off + 3, 2, 2);
        // K(3): Copyright
        this.isCopyrighted = common_1.default.isBitSet(buf, off + 3, 4);
        // L(2): Original
        this.isOriginalMedia = common_1.default.isBitSet(buf, off + 3, 5);
        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.
        this.emphasis = common_1.default.getBitAllignedNumber(buf, off + 3, 7, 2);
        this.version = MpegFrameHeader.VersionID[this.versionIndex];
        if (this.version === null)
            throw new Error('Invalid MPEG Audio version');
        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];
        this.samplingRate = this.calcSamplingRate();
        var bitrateInKbps = this.calcBitrate();
        this.bitrate = bitrateInKbps == null ? null : bitrateInKbps * 1000;
        this.samplingRate = this.calcSamplingRate();
    }
    MpegFrameHeader.prototype.calcDuration = function (numFrames) {
        return Math.round(numFrames * (this.calcSamplesPerFrame() / this.samplingRate));
    };
    MpegFrameHeader.prototype.calcSamplesPerFrame = function () {
        if (this.layer === 1)
            return 384;
        if (this.layer === 2)
            return 1152;
        if (this.layer === 3 && this.version === 1)
            return 1152;
        if (this.layer === 3 && (this.version === 2 || this.version === 2.5))
            return 576;
    };
    MpegFrameHeader.prototype.calculateSideInfoLength = function () {
        if (this.layer !== 3)
            return 2;
        if (this.channelModeIndex === 3) {
            // mono
            if (this.version === 1) {
                return 17;
            }
            else if (this.version === 2 || this.version === 2.5) {
                return 9;
            }
        }
        else {
            if (this.version === 1) {
                return 32;
            }
            else if (this.version === 2 || this.version === 2.5) {
                return 17;
            }
        }
    };
    MpegFrameHeader.prototype.calcSlotSize = function () {
        return [null, 4, 1, 1][this.layer];
    };
    MpegFrameHeader.prototype.calcBitrate = function () {
        if (this.bitrateIndex === 0x00)
            return null; // free
        if (this.bitrateIndex === 0x0F)
            return null; // 'reserved'
        var mpegVersion = this.version.toString() + this.layer;
        return MpegFrameHeader.bitrate_index[this.bitrateIndex][mpegVersion];
    };
    MpegFrameHeader.prototype.calcSamplingRate = function () {
        if (this.sampRateFreqIndex === 0x03)
            return null; // 'reserved'
        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];
    };
    MpegFrameHeader.SyncByte1 = 0xFF;
    MpegFrameHeader.SyncByte2 = 0xE0;
    MpegFrameHeader.VersionID = [2.5, null, 2, 1];
    MpegFrameHeader.LayerDescription = [null, 3, 2, 1];
    MpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];
    MpegFrameHeader.bitrate_index = {
        0x01: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },
        0x02: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },
        0x03: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },
        0x04: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },
        0x05: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },
        0x06: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },
        0x07: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },
        0x08: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },
        0x09: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },
        0x0A: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },
        0x0B: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },
        0x0C: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },
        0x0D: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },
        0x0E: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }
    };
    MpegFrameHeader.sampling_rate_freq_index = {
        1: { 0x00: 44100, 0x01: 48000, 0x02: 32000 },
        2: { 0x00: 22050, 0x01: 24000, 0x02: 16000 },
        2.5: { 0x00: 11025, 0x01: 12000, 0x02: 8000 }
    };
    return MpegFrameHeader;
}());
/**
 * MPEG Audio Layer I/II/III
 */
var MpegAudioLayer = (function () {
    function MpegAudioLayer() {
    }
    MpegAudioLayer.getVbrCodecProfile = function (vbrScale) {
        return 'V' + (100 - vbrScale) / 10;
    };
    MpegAudioLayer.FrameHeader = {
        len: 4,
        get: function (buf, off) {
            return new MpegFrameHeader(buf, off);
        }
    };
    /**
     * Info Tag
     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html
     */
    MpegAudioLayer.InfoTag = {
        len: 140,
        get: function (buf, off) {
            return {
                // 4 bytes for Header Tag
                headerTag: new strtok.StringType(4, 'ascii').get(buf, off),
                // 4 bytes for HeaderFlags
                headerFlags: new strtok.BufferType(4).get(buf, off + 4),
                // 100 bytes for entry (NUMTOCENTRIES)
                // numToCentries: new strtok.BufferType(100).get(buf, off + 8),
                // FRAME SIZE
                // frameSize: strtok.UINT32_BE.get(buf, off + 108),
                numFrames: strtok.UINT32_BE.get(buf, off + 8),
                numToCentries: new strtok.BufferType(100).get(buf, off + 108),
                // the number of header APE_HEADER bytes
                streamSize: strtok.UINT32_BE.get(buf, off + 112),
                // the number of header data bytes (from original file)
                vbrScale: strtok.UINT32_BE.get(buf, off + 116),
                /**
                 * LAME Tag, extends the Xing header format
                 * First added in LAME 3.12 for VBR
                 * The modified header is also included in CBR files (effective LAME 3.94), with "Info" instead of "XING" near the beginning.
                 */
                //  Initial LAME info, e.g.: LAME3.99r
                encoder: new strtok.StringType(9, 'ascii').get(buf, off + 120),
                //  Info Tag
                infoTag: strtok.UINT8.get(buf, off + 129) >> 4,
                // VBR method
                vbrMethod: strtok.UINT8.get(buf, off + 129) & 0xf
            };
        }
    };
    return MpegAudioLayer;
}());
var MpegParser = (function () {
    function MpegParser(headerSize) {
        this.frameCount = 0;
        this.bitrates = [];
        this.calculateVbrDuration = false;
        this.headerSize = headerSize;
    }
    MpegParser.prototype.parse = function (stream, tagEvent, done, readDuration, fileSize) {
        var _this = this;
        this.stream = stream;
        this.tagEvent = tagEvent;
        this.done = done;
        this.readDuration = readDuration;
        this.fileSize = fileSize;
        this.state = State.mpegSearchSync1;
        strtok.parse(stream, function (v, cb) {
            try {
                return _this.strParse(v, cb);
            }
            catch (error) {
                return done(error);
            }
        });
    };
    MpegParser.prototype.end = function (callback, done) {
        if (this.calculateVbrDuration) {
            this.tagEvent('format', 'duration', this.audioFrameHeader.calcDuration(this.frameCount));
        }
        return done();
    };
    MpegParser.prototype.strParse = function (v, cb) {
        var _this = this;
        if (v === undefined) {
            return strtok.UINT8;
        }
        switch (this.state) {
            case State.mpegSearchSync1:
                this.state = v === MpegFrameHeader.SyncByte1 ? State.mpegSearchSync2 : State.mpegSearchSync1;
                return strtok.UINT8;
            case State.mpegSearchSync2:
                if ((v & 0xE0) === 0xE0) {
                    // Synchronized
                    this.state = State.audio_frame_header;
                    this.frameSyncByte2 = v;
                    return new strtok.BufferType(2);
                }
                else {
                    this.state = State.mpegSearchSync1;
                    return strtok.UINT8;
                }
            /* falls through */
            case State.audio_frame_header:
                // we have found the mm tag at the end of the file, ignore
                /*
                 if (v.slice(0, 3).toString() === 'TAG') {
                 return done()
                 }*/
                var buf_frame_header = new Buffer(4);
                v.copy(buf_frame_header, 2);
                buf_frame_header[0] = MpegFrameHeader.SyncByte1;
                buf_frame_header[1] = this.frameSyncByte2;
                var header_1 = MpegAudioLayer.FrameHeader.get(buf_frame_header, 0);
                if (header_1.version === null || header_1.layer === null) {
                    return this.seekFirstAudioFrame();
                }
                // mp3 files are only found in MPEG1/2 Layer 3
                if ((header_1.version !== 1 && header_1.version !== 2) || header_1.layer !== 3) {
                    return this.seekFirstAudioFrame();
                }
                if (header_1.bitrate == null) {
                    return this.seekFirstAudioFrame();
                }
                if (header_1.samplingRate == null) {
                    return this.seekFirstAudioFrame();
                }
                this.tagEvent('format', 'dataformat', 'mp3');
                this.tagEvent('format', 'lossless', false);
                this.tagEvent('format', 'bitrate', header_1.bitrate);
                this.tagEvent('format', 'sampleRate', header_1.samplingRate);
                this.tagEvent('format', 'numberOfChannels', header_1.channelMode === 'mono' ? 1 : 2);
                var slot_size = header_1.calcSlotSize();
                if (slot_size == null) {
                    this.done(new Error('invalid slot_size'));
                }
                var samples_per_frame = header_1.calcSamplesPerFrame();
                var bps = samples_per_frame / 8.0;
                var fsize = (bps * header_1.bitrate / header_1.samplingRate) +
                    ((header_1.padding) ? slot_size : 0);
                this.frame_size = Math.floor(fsize);
                this.audioFrameHeader = header_1;
                this.frameCount++;
                this.bitrates.push(header_1.bitrate);
                // xtra header only exists in first frame
                if (this.frameCount === 1) {
                    this.offset = MpegAudioLayer.FrameHeader.len;
                    return this.skipSideInformation(header_1);
                }
                if (this.fileSize && this.frameCount === 3) {
                    // the stream is CBR if the first 3 frame bitrates are the same
                    if (this.areAllSame(this.bitrates)) {
                        this.fileSize(function (size) {
                            // subtract non audio stream data from duration calculation
                            size = size - _this.headerSize;
                            _this.tagEvent('format', 'duration', (size * 8) / header_1.bitrate);
                            // cb(done())
                            return _this.done();
                        });
                        return strtok.DEFER;
                    }
                    else if (!this.readDuration) {
                        return this.done();
                    }
                }
                // once we know the file is VBR attach listener to end of
                // stream so we can do the duration calculation when we
                // have counted all the frames
                if (this.readDuration && this.frameCount === 4) {
                    return this.calculateVbrDuration = true;
                }
                this.offset = 4;
                if (header_1.isProtectedByCRC) {
                    this.state = State.CRC;
                    return strtok.INT16_BE;
                }
                else {
                    return this.skipSideInformation(header_1);
                }
            case State.CRC:
                this.offset += 2;
                this.crc = v;
                return this.skipSideInformation(this.audioFrameHeader);
            case State.side_information:
                this.offset += MpegAudioLayer.InfoTag.len; // 12
                this.state = State.xtra_info_header;
                return MpegAudioLayer.InfoTag;
            case State.xtra_info_header:
                this.state = State.skip_frame_data;
                var frameDataLeft = this.frame_size - this.offset;
                var codecProfile = void 0;
                switch (v.headerTag) {
                    case 'Info':
                        codecProfile = 'CBR';
                        break;
                    case 'Xing':
                        codecProfile = MpegAudioLayer.getVbrCodecProfile(v.vbrScale);
                        break;
                    case 'Xtra':
                        // ToDo: ???
                        break;
                    default:
                        return new strtok.IgnoreType(frameDataLeft);
                }
                this.tagEvent('format', 'encoder', v.encoder);
                this.tagEvent('format', 'codecProfile', codecProfile);
                // frames field is not present
                if ((v.headerFlags[3] & 0x01) !== 1) {
                    return new strtok.IgnoreType(frameDataLeft);
                }
                this.tagEvent('format', 'duration', this.audioFrameHeader.calcDuration(v.numFrames));
                return this.done();
            case State.skip_frame_data:
                this.state = State.mpegSearchSync1;
                return strtok.UINT8;
            default:
                this.done(new Error('Undefined state: ' + this.state));
        }
    };
    MpegParser.prototype.skipSideInformation = function (header) {
        var sideinfo_length = header.calculateSideInfoLength();
        this.offset += sideinfo_length;
        this.state = State.side_information;
        return new strtok.BufferType(sideinfo_length);
    };
    MpegParser.prototype.seekFirstAudioFrame = function () {
        if (this.frameCount > 0) {
            return this.done(new Error('expected frame header but was not found'));
        }
        this.state = State.mpegSearchSync1;
        return strtok.UINT8;
    };
    MpegParser.prototype.areAllSame = function (array) {
        var first = array[0];
        return array.every(function (element) {
            return element === first;
        });
    };
    return MpegParser;
}());
exports.MpegParser = MpegParser;
//# sourceMappingURL=mpeg.js.map