'use strict';
var events = require("events");
var strtok = require("strtok2");
var common_1 = require("./common");
var vorbis_1 = require("./vorbis");
var State;
(function (State) {
    State[State["header"] = 0] = "header";
    State[State["segments"] = 1] = "segments";
    State[State["pageData"] = 2] = "pageData";
})(State || (State = {}));
var MetaState;
(function (MetaState) {
    MetaState[MetaState["type"] = 0] = "type";
    MetaState[MetaState["vendorLength"] = 1] = "vendorLength";
    MetaState[MetaState["vendorString"] = 2] = "vendorString";
    MetaState[MetaState["userCommentListLength"] = 3] = "userCommentListLength";
    MetaState[MetaState["commentLength"] = 4] = "commentLength";
    MetaState[MetaState["comment"] = 5] = "comment";
    MetaState[MetaState["vorbisInfo"] = 6] = "vorbisInfo";
})(MetaState || (MetaState = {}));
var OggParser = (function () {
    function OggParser() {
    }
    OggParser.getInstance = function () {
        return new OggParser();
    };
    OggParser.prototype.parse = function (stream, callback, done, readDuration, fileSize) {
        var _this = this;
        var innerStream = new events.EventEmitter();
        var pageLength = 0;
        var stop = false;
        // top level parser that handles the parsing of pages
        strtok.parse(stream, function (v, cb) {
            if (!v) {
                cb.state = State.header;
                return OggParser.Header;
            }
            if (stop) {
                return done();
            }
            switch (cb.state) {
                case State.header:
                    _this.header = v;
                    if (_this.header.type !== 'OggS') {
                        return done(new Error('expected ogg header but was not found'));
                    }
                    cb.pageNumber = _this.header.page_number;
                    cb.state++;
                    return new strtok.BufferType(_this.header.segments);
                case State.segments:
                    pageLength = common_1.default.sum(v);
                    cb.state++;
                    return new strtok.BufferType(pageLength);
                case State.pageData:
                    innerStream.emit('data', new Buffer(v));
                    cb.state = State.header;
                    return OggParser.Header;
                default:
                    done(new Error('Illegal state'));
            }
        });
        // Second level parser that handles the parsing of metadata.
        // The top level parser emits data that this parser should
        // handle.
        strtok.parse(innerStream, function (v, cb) {
            if (!v) {
                cb.commentsRead = 0;
                cb.state = MetaState.type;
                return new strtok.BufferType(7);
            }
            switch (cb.state) {
                case MetaState.type:
                    if (v.toString() === '\x01vorbis') {
                        cb.state = MetaState.vorbisInfo;
                        return new strtok.BufferType(23);
                    }
                    else if (v.toString() === '\x03vorbis') {
                        cb.state++;
                        return strtok.UINT32_LE;
                    }
                    else {
                        return done(new Error('expected vorbis header but found something else'));
                    }
                case MetaState.vendorLength:
                    cb.state++;
                    return new strtok.BufferType(v);
                case MetaState.vendorString:
                    cb.state++;
                    return new strtok.BufferType(4);
                case MetaState.userCommentListLength:
                    cb.commentsLength = v.readUInt32LE(0);
                    // no metadata, stop parsing
                    if (cb.commentsLength === 0)
                        return strtok.DONE;
                    cb.state++;
                    return strtok.UINT32_LE;
                case MetaState.commentLength:
                    cb.state++;
                    return new strtok.BufferType(v);
                case MetaState.comment:
                    cb.commentsRead++;
                    v = v.toString();
                    var idx = v.indexOf('=');
                    var key = v.slice(0, idx).toUpperCase();
                    var value = v.slice(idx + 1);
                    if (key === 'METADATA_BLOCK_PICTURE') {
                        value = vorbis_1.default.readPicture(new Buffer(value, 'base64'));
                    }
                    callback(OggParser.headerType, key, value);
                    if (cb.commentsRead === cb.commentsLength) {
                        // if we don't want to read the duration
                        // then tell the parent stream to stop
                        stop = !readDuration;
                        return strtok.DONE;
                    }
                    cb.state--; // back to comment length
                    return strtok.UINT32_LE;
                case MetaState.vorbisInfo:
                    _this.formatInfo = {
                        version: v.readUInt32LE(0),
                        channelMode: v.readUInt8(4),
                        sampleRate: v.readUInt32LE(5),
                        bitrateMax: v.readUInt32LE(9),
                        bitrateNominal: v.readUInt32LE(13),
                        bitrateMin: v.readUInt32LE(17)
                    };
                    callback('format', 'headerType', OggParser.headerType);
                    callback('format', 'sampleRate', _this.formatInfo.sampleRate);
                    callback('format', 'bitrate', _this.formatInfo.bitrateNominal);
                    callback('format', 'numberOfChannels', _this.formatInfo.channelMode);
                    cb.state = MetaState.type;
                    return new strtok.BufferType(7);
                default:
                    done(new Error('Illegal metadata-state: ' + cb.state));
                    return strtok.DONE;
            }
        });
    };
    OggParser.prototype.end = function (callback, done) {
        callback('format', 'duration', this.header.pcm_sample_pos / this.formatInfo.sampleRate);
        done();
    };
    return OggParser;
}());
OggParser.Header = {
    len: 27,
    get: function (buf, off) {
        return {
            type: new strtok.StringType(4, 'ascii').get(buf, off + 0),
            version: buf.readUInt8(off + 4),
            packet_flag: buf.readUInt8(off + 5),
            pcm_sample_pos: (buf.readUInt32LE(off + 10) << 32) + buf.readUInt32LE(off + 6),
            stream_serial_num: strtok.UINT32_LE.get(buf, off + 14),
            page_number: strtok.UINT32_LE.get(buf, off + 18),
            check_sum: strtok.UINT32_LE.get(buf, off + 22),
            segments: buf.readUInt8(off + 26)
        };
    }
};
OggParser.headerType = 'vorbis';
module.exports = OggParser.getInstance();
//# sourceMappingURL=ogg.js.map