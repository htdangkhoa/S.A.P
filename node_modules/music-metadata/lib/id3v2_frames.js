"use strict";
var strtok = require("strtok2");
var common_1 = require("./common");
var vorbis_1 = require("./vorbis");
var FrameParser = (function () {
    function FrameParser() {
    }
    FrameParser.readData = function (b, type, flags, major) {
        var encoding = FrameParser.getTextEncoding(b[0]);
        var length = b.length;
        var offset = 0;
        var output = []; // ToDo
        var nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);
        var fzero;
        var out = {};
        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {
            case 'T*': // 4.2.1. Text information frames - details
            case 'IPLS':
                var text = common_1.default.decodeString(b.slice(1), encoding).replace(/\x00+$/, '');
                // id3v2.4 defines that multiple T* values are separated by 0x00
                // id3v2.3 defines that multiple T* values are separated by /
                switch (type) {
                    case 'TMCL': // Musician credits list
                    case 'TIPL': // Involved people list
                    case 'IPLS':
                        output = FrameParser.splitValue(4, text);
                        output = FrameParser.functionList(output);
                        break;
                    case 'TRK':
                    case 'TRCK':
                    case 'TPOS':
                        output = text;
                        break;
                    default:
                        output = FrameParser.splitValue(major, text);
                }
                break;
            case 'TXXX':
                output = FrameParser.readIdentifierAndData(b, offset + 1, length, encoding);
                output = {
                    description: output.id,
                    text: FrameParser.splitValue(major, common_1.default.decodeString(output.data, encoding).replace(/\x00+$/, ''))
                };
                break;
            case 'PIC':
            case 'APIC':
                var pic = {};
                offset += 1;
                switch (major) {
                    case 2:
                        pic.format = common_1.default.decodeString(b.slice(offset, offset + 3), encoding);
                        offset += 3;
                        break;
                    case 3:
                    case 4:
                        var enc = 'iso-8859-1';
                        fzero = common_1.default.findZero(b, offset, length, enc);
                        pic.format = common_1.default.decodeString(b.slice(offset, fzero), enc);
                        offset = fzero + 1;
                        break;
                    default:
                        throw new Error('Warning: unexpected major versionIndex: ' + major);
                }
                pic.type = vorbis_1.default.getPictureType(b[offset]);
                offset += 1;
                fzero = common_1.default.findZero(b, offset, length, encoding);
                pic.description = common_1.default.decodeString(b.slice(offset, fzero), encoding);
                offset = fzero + nullTerminatorLength;
                pic.data = new Buffer(b.slice(offset, length));
                output = pic;
                break;
            case 'CNT':
            case 'PCNT':
                output = strtok.UINT32_BE.get(b, 0);
                break;
            case 'SYLT':
                // skip text encoding (1 byte),
                //      language (3 bytes),
                //      time stamp format (1 byte),
                //      content headerType (1 byte),
                //      content descriptor (1 byte)
                offset += 7;
                output = [];
                while (offset < length) {
                    var txt = b.slice(offset, offset = common_1.default.findZero(b, offset, length, encoding));
                    offset += 5; // push offset forward one +  4 byte timestamp
                    output.push(common_1.default.decodeString(txt, encoding));
                }
                break;
            case 'ULT':
            case 'USLT':
            case 'COM':
            case 'COMM':
                offset += 1;
                out.language = common_1.default.decodeString(b.slice(offset, offset + 3), 'iso-8859-1');
                offset += 3;
                fzero = common_1.default.findZero(b, offset, length, encoding);
                out.description = common_1.default.decodeString(b.slice(offset, fzero), encoding);
                offset = fzero + nullTerminatorLength;
                out.text = common_1.default.decodeString(b.slice(offset, length), encoding).replace(/\x00+$/, '');
                output = [out];
                break;
            case 'UFID':
                output = FrameParser.readIdentifierAndData(b, offset, length, 'iso-8859-1');
                output = { owner_identifier: output.id, identifier: output.data };
                break;
            case 'PRIV':
                output = FrameParser.readIdentifierAndData(b, offset, length, 'iso-8859-1');
                output = { owner_identifier: output.id, data: output.data };
                break;
            default:
                // ToDO? console.log('Warning: unsupported id3v2-tag-type: ' + type)
                break;
        }
        return output;
    };
    /**
     * Converts TMCL (Musician credits list) or TIPL (Involved people list)
     * @param entries
     */
    FrameParser.functionList = function (entries) {
        var res = {};
        for (var i = 0; i + 1 < entries.length; i += 2) {
            var names = entries[i + 1].split(',');
            res[entries[i]] = res.hasOwnProperty(entries[i]) ? res[entries[i]].concat(names) : names;
        }
        return res;
    };
    FrameParser.splitValue = function (major, text) {
        var values = text.split(major >= 4 ? /\x00/g : /\//g);
        return FrameParser.trimArray(values);
    };
    FrameParser.trimArray = function (values) {
        for (var i = 0; i < values.length; ++i) {
            values[i] = values[i].replace(/\x00+$/, '').trim();
        }
        return values;
    };
    FrameParser.readIdentifierAndData = function (b, offset, length, encoding) {
        var fzero = common_1.default.findZero(b, offset, length, encoding);
        var id = common_1.default.decodeString(b.slice(offset, fzero), encoding);
        offset = fzero + FrameParser.getNullTerminatorLength(encoding);
        return { id: id, data: b.slice(offset, length) };
    };
    FrameParser.getTextEncoding = function (byte) {
        switch (byte) {
            case 0x00:
                return 'iso-8859-1'; // binary
            case 0x01:
            case 0x02:
                return 'utf16'; // 01 = with bom, 02 = without bom
            case 0x03:
                return 'utf8';
            default:
                return 'utf8';
        }
    };
    FrameParser.getNullTerminatorLength = function (enc) {
        switch (enc) {
            case 'utf16':
                return 2;
            default:
                return 1;
        }
    };
    return FrameParser;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = FrameParser;
// exports.readData = function readData (b, type, flags, major) {
//# sourceMappingURL=id3v2_frames.js.map