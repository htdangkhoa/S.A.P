import { HeaderType } from './tagmap';
import EventEmitter = NodeJS.EventEmitter;
import ReadableStream = NodeJS.ReadableStream;
export interface IPicture {
    format: string;
    data: Uint8Array;
}
export interface ICommonTagsResult {
    track: {
        no: number;
        of: number;
    };
    disk: {
        no: number;
        of: number;
    };
    year?: number;
    title?: string;
    artist?: string;
    artists?: string[];
    albumartist?: string;
    album?: string;
    date?: string;
    originaldate?: string;
    originalyear?: number;
    comment?: string;
    genre?: string[];
    picture?: IPicture[];
    composer?: string[];
    lyrics?: string[];
    albumsort?: string;
    titlesort?: string;
    work?: string;
    artistsort?: string;
    albumartistsort?: string;
    composersort?: string[];
    lyricist?: string[];
    writer?: string[];
    conductor?: string[];
    remixer?: string[];
    arranger?: string[];
    engineer?: string[];
    producer?: string[];
    djmixer?: string[];
    mixer?: string[];
    label?: string;
    grouping?: string[];
    subtitle?: string[];
    discsubtitle?: string[];
    totaltracks?: string;
    totaldiscs?: string;
    compilation?: string;
    _rating?: string;
    bpm?: string;
    mood?: string;
    media?: string;
    catalognumber?: string;
    show?: string;
    showsort?: string;
    podcast?: string;
    podcasturl?: string;
    releasestatus?: string;
    releasetype?: string[];
    releasecountry?: string;
    script?: string;
    language?: string;
    copyright?: string;
    license?: string;
    encodedby?: string;
    encodersettings?: string;
    gapless?: string;
    barcode?: string;
    isrc?: string;
    asin?: string;
    musicbrainz_recordingid?: string;
    musicbrainz_trackid?: string;
    musicbrainz_albumid?: string;
    musicbrainz_artistid?: string[];
    musicbrainz_albumartistid?: string[];
    musicbrainz_releasegroupid?: string;
    musicbrainz_workid?: string;
    musicbrainz_trmid?: string;
    musicbrainz_discid?: string;
    acoustid_id?: string;
    acoustid_fingerprint?: string;
    musicip_puid?: string;
    musicip_fingerprint?: string;
    website?: string;
    'performer:instrument'?: string[];
    averageLevel?: number;
    peakLevel?: number;
}
export interface IFormat {
    dataformat?: string;
    type?: HeaderType;
    /**
     * Duration in seconds
     */
    duration?: number;
    /**
     * Number bits per second of encoded audio file
     */
    bitrate?: number;
    /**
     * Sampling rate in Samples per second (S/s)
     */
    sampleRate?: number;
    /**
     * Audio bit depth
     */
    bitsPerSample?: number;
    /**
     * Encoder name, e.g.:
     */
    encoder?: string;
    /**
     * Codec profile
     */
    codecProfile?: string;
    lossless?: boolean;
    /**
     * Number of audio channels
     */
    numberOfChannels?: number;
}
export interface IResult {
    common: ICommonTagsResult;
    format: IFormat;
}
export declare type ICallbackType = (error?: Error, result?: IResult) => void;
export interface IOptions {
    path?: string;
    fileSize?: string;
    native?: boolean;
    duration?: boolean;
}
export interface IFileSize {
    fileSize?: (size: number) => void;
}
/**
 * Parse audio stream
 * @param stream
 * @param opts
 *   .filesize=true  Return filesize
 *   .native=true    Will return original header in result
 * @param callback
 * @returns {*|EventEmitter}
 */
export declare function parseStream(stream: ReadableStream, opts: IOptions, callback: ICallbackType): EventEmitter;
