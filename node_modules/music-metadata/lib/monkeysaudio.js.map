{"version":3,"file":"monkeysaudio.js","sourceRoot":"","sources":["../src/monkeysaudio.ts"],"names":[],"mappings":"AAAA,YAAY,CAAC;AAEb,gCAAkC;AAClC,mCAA8B;AA4F9B,IAAK,QAKJ;AALD,WAAK,QAAQ;IACX,iDAAa,CAAA;IACb,2CAAU,CAAA;IACV,yDAAiB,CAAA;IACjB,+CAAY,CAAA;AACd,CAAC,EALI,QAAQ,KAAR,QAAQ,QAKZ;AAED;IAAA;IA0GA,CAAC;IAnBe,uBAAa,GAA3B,UAA4B,KAAK;QAC/B,MAAM,CAAC;YACL,cAAc,EAAE,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC;YAC7C,cAAc,EAAE,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC;YAC7C,QAAQ,EAAE,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,EAAE,CAAC;YACvC,QAAQ,EAAE,SAAS,CAAC,QAAQ,CAAC,KAAK,EAAE,CAAC,CAAC;YACtC,QAAQ,EAAE,CAAC,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC;SAC3B,CAAC;IACJ,CAAC;IAED;;;;OAIG;IACW,kBAAQ,GAAtB,UAAuB,GAAG,EAAE,GAAG;QAC7B,MAAM,CAAC,CAAC,GAAG,GAAG,CAAC,IAAI,GAAG,CAAC,KAAK,CAAC,CAAC;IAChC,CAAC;IAEH,gBAAC;AAAD,CAAC,AA1GD;AACE;;GAEG;AACW,0BAAgB,GAAG;IAC/B,GAAG,EAAE,EAAE;IAEP,GAAG,EAAE,UAAC,GAAG,EAAE,GAAG;QACZ,MAAM,CAAC;YACL,sBAAsB;YACtB,EAAE,EAAE,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;YACnD,wGAAwG;YACxG,OAAO,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI;YAClD,yEAAyE;YACzE,eAAe,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;YACnD,wCAAwC;YACxC,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YAChD,wCAAwC;YACxC,cAAc,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YACnD,uDAAuD;YACvD,eAAe,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YACpD,wCAAwC;YACxC,iBAAiB,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YACtD,gDAAgD;YAChD,qBAAqB,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YAC1D,4DAA4D;YAC5D,oBAAoB,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YACzD,yEAAyE;YACzE,OAAO,EAAE,IAAI,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;SACtD,CAAC;IACJ,CAAC;CACF,CAAC;AAEF;;GAEG;AACW,gBAAM,GAAG;IACrB,GAAG,EAAE,EAAE;IAEP,GAAG,EAAE,UAAC,GAAG,EAAE,GAAG;QACZ,MAAM,CAAC;YACL,kEAAkE;YAClE,gBAAgB,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;YAChD,oCAAoC;YACpC,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;YAC/C,0CAA0C;YAC1C,cAAc,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;YAClD,gDAAgD;YAChD,gBAAgB,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;YACpD,6BAA6B;YAC7B,WAAW,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YAChD,qCAAqC;YACrC,aAAa,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YAClD,kCAAkC;YAClC,OAAO,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YAC5C,oCAAoC;YACpC,UAAU,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;SAChD,CAAC;IACJ,CAAC;CACF,CAAC;AAEF;;GAEG;AACW,mBAAS,GAAG;IACxB,GAAG,EAAE,EAAE;IAEP,GAAG,EAAE,UAAC,GAAG,EAAE,GAAG;QACZ,MAAM,CAAC;YACL,0BAA0B;YAC1B,EAAE,EAAE,IAAI,MAAM,CAAC,UAAU,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,CAAC;YACnD,iCAAiC;YACjC,OAAO,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,CAAC,CAAC;YAC3C,wEAAwE;YACxE,IAAI,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YACzC,kCAAkC;YAClC,MAAM,EAAE,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC;YAC3C,wCAAwC;YACxC,QAAQ,EAAE,IAAI,MAAM,CAAC,UAAU,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,GAAG,GAAG,EAAE,CAAC,CAAC,wBAAwB;SAChF,CAAC;IACJ,CAAC;CACF,CAAC;AAEY,kBAAQ,GAAG,UAAC,MAAM;IAC9B,MAAM,CAAC,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,IAAI,GAAG,SAAS,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC;AACtE,CAAC,CAAA;AA2BF,CAAC;AAEF;IAAA;QAgBU,SAAI,GAAe,OAAO,CAAC,CAAC,sEAAsE;QAElG,QAAG,GAAa,EAAE,CAAC;IAqH7B,CAAC;IArIe,qBAAW,GAAzB;QACE,MAAM,CAAC,IAAI,SAAS,EAAE,CAAC;IACzB,CAAC;IACD;;;;OAIG;IACW,2BAAiB,GAA/B,UAAgC,EAAW;QACzC,IAAI,QAAQ,GAAG,EAAE,CAAC,WAAW,GAAG,CAAC,GAAG,EAAE,CAAC,cAAc,GAAG,CAAC,EAAE,CAAC,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC;QACjF,QAAQ,IAAI,EAAE,CAAC,gBAAgB,CAAC;QAChC,MAAM,CAAC,QAAQ,GAAG,EAAE,CAAC,UAAU,CAAC;IAClC,CAAC;IAMM,yBAAK,GAAZ,UAAa,MAAM,EAAE,QAAqB,EAAE,IAAK,EAAE,YAAa,EAAE,QAAS;QAA3E,iBA+DC;QA7DC,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,UAAC,CAAC,EAAE,EAAE;YACzB,EAAE,CAAC,CAAC,CAAC,KAAK,SAAS,CAAC,CAAC,CAAC;gBACpB,EAAE,CAAC,KAAK,GAAG,YAAY,CAAC;gBACxB,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC;YACpC,CAAC;YAED,MAAM,CAAC,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;gBACjB,KAAK,YAAY;oBACf,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,MAAM,CAAC,CAAC,CAAC;wBACpB,MAAM,IAAI,KAAK,CAAC,mCAAmC,CAAC,CAAC,CAAC,yBAAyB;oBACjF,CAAC;oBACD,KAAI,CAAC,GAAG,CAAC,UAAU,GAAG,CAAC,CAAC;oBACxB,IAAM,MAAM,GAAG,CAAC,CAAC,eAAe,GAAG,SAAS,CAAC,gBAAgB,CAAC,GAAG,CAAC;oBAClE,EAAE,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;wBACf,EAAE,CAAC,KAAK,GAAG,qBAAqB,CAAC;wBACjC,MAAM,CAAC,IAAI,MAAM,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;oBACvC,CAAC;oBAAC,IAAI,CAAC,CAAC;wBACN,EAAE,CAAC,KAAK,GAAG,QAAQ,CAAC;wBACpB,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC;oBAC1B,CAAC;gBAEH,KAAK,qBAAqB;oBACxB,EAAE,CAAC,KAAK,GAAG,QAAQ,CAAC;oBACpB,MAAM,CAAC,SAAS,CAAC,MAAM,CAAC;gBAE1B,KAAK,QAAQ;oBACX,KAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;oBACpB,QAAQ,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAK,CAAC,CAAC;oBACxC,QAAQ,CAAC,QAAQ,EAAE,UAAU,EAAE,IAAI,CAAC,CAAC;oBACrC,QAAQ,CAAC,QAAQ,EAAE,YAAY,EAAE,KAAI,CAAC,IAAI,CAAC,CAAC;oBAC5C,QAAQ,CAAC,QAAQ,EAAE,eAAe,EAAE,CAAC,CAAC,aAAa,CAAC,CAAC;oBACrD,QAAQ,CAAC,QAAQ,EAAE,YAAY,EAAE,CAAC,CAAC,UAAU,CAAC,CAAC;oBAC/C,QAAQ,CAAC,QAAQ,EAAE,kBAAkB,EAAE,CAAC,CAAC,OAAO,CAAC,CAAC;oBAClD,QAAQ,CAAC,QAAQ,EAAE,UAAU,EAAE,SAAS,CAAC,iBAAiB,CAAC,CAAC,CAAC,CAAC,CAAC;oBAC/D,IAAM,YAAY,GAAG,KAAI,CAAC,GAAG,CAAC,UAAU,CAAC,cAAc,GAAG,KAAI,CAAC,GAAG,CAAC,UAAU,CAAC,eAAe;wBAC3F,KAAI,CAAC,GAAG,CAAC,UAAU,CAAC,iBAAiB,GAAG,KAAI,CAAC,GAAG,CAAC,UAAU,CAAC,oBAAoB,CAAC;oBACnF,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC;oBACtB,MAAM,CAAC,IAAI,MAAM,CAAC,UAAU,CAAC,YAAY,CAAC,CAAC;gBAE7C,KAAK,UAAU;oBACb,EAAE,CAAC,KAAK,GAAG,WAAW,CAAC;oBACvB,MAAM,CAAC,SAAS,CAAC,SAAS,CAAC;gBAE7B,KAAK,WAAW;oBACd,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE,KAAK,UAAU,CAAC,CAAC,CAAC;wBACxB,IAAI,CAAC,IAAI,KAAK,CAAC,yCAAyC,CAAC,CAAC,CAAC;oBAC7D,CAAC;oBACD,KAAI,CAAC,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;oBACpB,EAAE,CAAC,KAAK,GAAG,UAAU,CAAC;oBACtB,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;gBAE/B,KAAK,UAAU;oBACb,KAAI,CAAC,SAAS,CAAC,KAAI,CAAC,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,QAAQ,CAAC,CAAC;oBAC7C,IAAI,EAAE,CAAC;oBACP,KAAK,CAAC;gBAER;oBACE,IAAI,CAAC,IAAI,KAAK,CAAC,iBAAiB,GAAG,EAAE,CAAC,KAAK,CAAC,CAAC,CAAC;YAClD,CAAC;YACD,MAAM,CAAC,CAAC,CAAC;QACX,CAAC,CAAC,CAAC;IACL,CAAC;IAAA,CAAC;IAEM,6BAAS,GAAjB,UAAkB,MAAe,EAAE,MAAc,EAAE,QAAQ;QACzD,IAAI,MAAM,GAAG,CAAC,CAAC;QAEf,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE,CAAC;YACvC,IAAM,IAAI,GAAG,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC;YAClD,MAAM,IAAI,CAAC,CAAC;YACZ,IAAM,KAAK,GAAG,SAAS,CAAC,aAAa,CAAC,MAAM,CAAC,SAAS,CAAC,GAAG,CAAC,MAAM,EAAE,MAAM,CAAC,CAAC,CAAC;YAC5E,MAAM,IAAI,CAAC,CAAC;YAEZ,IAAI,IAAI,GAAG,gBAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,CAAC,MAAM,CAAC,CAAC;YAC1D,IAAM,GAAG,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;YACnD,MAAM,GAAG,IAAI,GAAG,CAAC,CAAC;YAElB,MAAM,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACvB,KAAK,QAAQ,CAAC,SAAS;oBAAE,CAAC;wBACxB,IAAM,KAAK,GAAG,MAAM,CAAC,QAAQ,CAAC,MAAM,EAAE,MAAM,EAAE,MAAM,IAAI,IAAI,CAAC,CAAC;wBAC9D,IAAM,MAAM,GAAG,KAAK,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;wBAEpC,yBAAyB;wBACzB,GAAG,CAAC,CAAc,UAAM,EAAN,iBAAM,EAAN,oBAAM,EAAN,IAAM;4BAAnB,IAAM,GAAG,eAAA;4BACZ,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,GAAG,CAAC,CAAC;yBAC/B;oBACH,CAAC;oBACC,KAAK,CAAC;gBAER,KAAK,QAAQ,CAAC,MAAM;oBAAE,CAAC;wBACrB,EAAE,CAAC,CAAC,GAAG,KAAK,mBAAmB,IAAI,GAAG,KAAK,kBAAkB,CAAC,CAAC,CAAC;4BAC9D,IAAM,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,EAAE,MAAM,GAAG,IAAI,CAAC,CAAC;4BAEpD,IAAI,GAAG,GAAG,CAAC,CAAC;4BACZ,IAAI,GAAG,gBAAM,CAAC,QAAQ,CAAC,OAAO,EAAE,GAAG,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;4BACrD,IAAM,WAAW,GAAG,OAAO,CAAC,QAAQ,CAAC,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;4BACxD,GAAG,GAAG,IAAI,GAAG,CAAC,CAAC;4BAEf,IAAM,OAAO,GAAG;gCACd,WAAW,aAAA;gCACX,IAAI,EAAE,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;6BACrC,CAAC;4BAEF,MAAM,IAAI,IAAI,CAAC;4BACf,QAAQ,CAAC,IAAI,CAAC,IAAI,EAAE,GAAG,EAAE,OAAO,CAAC,CAAC;wBACpC,CAAC;oBACH,CAAC;oBACC,KAAK,CAAC;gBAER;oBACE,MAAM,IAAI,KAAK,CAAC,wBAAwB,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC;YAC/D,CAAC;QACH,CAAC;IACH,CAAC;IACH,gBAAC;AAAD,CAAC,AAvID,IAuIC;AAED,MAAM,CAAC,OAAO,GAAG,SAAS,CAAC,WAAW,EAAE,CAAC","sourcesContent":["'use strict';\n\nimport * as strtok from 'strtok2';\nimport common from './common';\nimport {IStreamParser, TagCallback} from './parser';\nimport {HeaderType} from './tagmap';\n\n/**\n * APETag versionIndex history / supported formats\n *\n *  1.0 (1000) - Original APE tag spec.  Fully supported by this code.\n *  2.0 (2000) - Refined APE tag spec (better streaming support, UTF encoding). Fully supported by this code.\n *\n *  Notes:\n *  - also supports reading of ID3v1.1 tags\n *  - all saving done in the APE Tag format using CURRENT_APE_TAG_VERSION\n *\n * APE File Format Overview: (pieces in order -- only valid for the latest versionIndex APE files)\n *\n * JUNK - any amount of \"junk\" before the APE_DESCRIPTOR (so people that put ID3v2 tags on the files aren't hosed)\n * APE_DESCRIPTOR - defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n * APE_HEADER - describes all of the necessary information about the APE file\n * SEEK TABLE - the table that represents seek offsets [optional]\n * HEADER DATA - the pre-audio data from the original file [optional]\n * APE FRAMES - the actual compressed audio (broken into frames for seekability)\n * TERMINATING DATA - the post-audio data from the original file [optional]\n * TAG - describes all the properties of the file [optional]\n */\n\ninterface IDescriptor {\n  // should equal 'MAC '\n  ID: string,\n  // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n  version: number,\n  // the number of descriptor bytes (allows later expansion of this header)\n  descriptorBytes: number,\n  // the number of header APE_HEADER bytes\n  headerBytes: number,\n  // the number of header APE_HEADER bytes\n  seekTableBytes: number,\n  // the number of header data bytes (from original file)\n  headerDataBytes: number,\n  // the number of bytes of APE frame data\n  apeFrameDataBytes: number,\n  // the high order number of APE frame data bytes\n  apeFrameDataBytesHigh: number,\n  // the terminating data of the file (not including tag data)\n  terminatingDataBytes: number,\n  // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n  fileMD5: number[]\n}\n\n/**\n * APE_HEADER: describes all of the necessary information about the APE file\n */\ninterface IHeader {\n  // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n  compressionLevel: number,\n  // any format flags (for future use)\n  formatFlags: number,\n  // the number of audio blocks in one frame\n  blocksPerFrame: number,\n  // the number of audio blocks in the final frame\n  finalFrameBlocks: number,\n  // the total number of frames\n  totalFrames: number,\n  // the bits per sample (typically 16)\n  bitsPerSample: number,\n  // the number of channels (1 or 2)\n  channel: number,\n  // the sample rate (typically 44100)\n  sampleRate: number\n}\n\ninterface IFooter {\n  // should equal 'APETAGEX'\n  ID: string,\n  // equals CURRENT_APE_TAG_VERSION\n  version: number,\n  // the complete size of the tag, including this footer (excludes header)\n  size: number,\n  // the number of fields in the tag\n  fields: number,\n  // reserved for later use (must be zero)\n  reserved: number[] // ToDo: what is this???\n}\n\ninterface ITagFlags {\n  containsHeader: boolean,\n  containsFooter: boolean,\n  isHeader: boolean,\n  readOnly: boolean,\n  dataType: DataType\n}\n\nenum DataType {\n  text_utf8 = 0,\n  binary = 1,\n  external_info = 2,\n  reserved = 3\n}\n\nclass Structure {\n  /**\n   * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\n   */\n  public static DescriptorParser = {\n    len: 52,\n\n    get: (buf, off) => {\n      return {\n        // should equal 'MAC '\n        ID: new strtok.StringType(4, 'ascii').get(buf, off),\n        // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n        version: strtok.UINT32_LE.get(buf, off + 4) / 1000,\n        // the number of descriptor bytes (allows later expansion of this header)\n        descriptorBytes: strtok.UINT32_LE.get(buf, off + 8),\n        // the number of header APE_HEADER bytes\n        headerBytes: strtok.UINT32_LE.get(buf, off + 12),\n        // the number of header APE_HEADER bytes\n        seekTableBytes: strtok.UINT32_LE.get(buf, off + 16),\n        // the number of header data bytes (from original file)\n        headerDataBytes: strtok.UINT32_LE.get(buf, off + 20),\n        // the number of bytes of APE frame data\n        apeFrameDataBytes: strtok.UINT32_LE.get(buf, off + 24),\n        // the high order number of APE frame data bytes\n        apeFrameDataBytesHigh: strtok.UINT32_LE.get(buf, off + 28),\n        // the terminating data of the file (not including tag data)\n        terminatingDataBytes: strtok.UINT32_LE.get(buf, off + 32),\n        // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n        fileMD5: new strtok.BufferType(16).get(buf, off + 36)\n      };\n    }\n  };\n\n  /**\n   * APE_HEADER: describes all of the necessary information about the APE file\n   */\n  public static Header = {\n    len: 24,\n\n    get: (buf, off) => {\n      return {\n        // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n        compressionLevel: strtok.UINT16_LE.get(buf, off),\n        // any format flags (for future use)\n        formatFlags: strtok.UINT16_LE.get(buf, off + 2),\n        // the number of audio blocks in one frame\n        blocksPerFrame: strtok.UINT32_LE.get(buf, off + 4),\n        // the number of audio blocks in the final frame\n        finalFrameBlocks: strtok.UINT32_LE.get(buf, off + 8),\n        // the total number of frames\n        totalFrames: strtok.UINT32_LE.get(buf, off + 12),\n        // the bits per sample (typically 16)\n        bitsPerSample: strtok.UINT16_LE.get(buf, off + 16),\n        // the number of channels (1 or 2)\n        channel: strtok.UINT16_LE.get(buf, off + 18),\n        // the sample rate (typically 44100)\n        sampleRate: strtok.UINT32_LE.get(buf, off + 20)\n      };\n    }\n  };\n\n  /**\n   * TAG: describes all the properties of the file [optional]\n   */\n  public static TagFooter = {\n    len: 32,\n\n    get: (buf, off) => {\n      return {\n        // should equal 'APETAGEX'\n        ID: new strtok.StringType(8, 'ascii').get(buf, off),\n        // equals CURRENT_APE_TAG_VERSION\n        version: strtok.UINT32_LE.get(buf, off + 8),\n        // the complete size of the tag, including this footer (excludes header)\n        size: strtok.UINT32_LE.get(buf, off + 12),\n        // the number of fields in the tag\n        fields: strtok.UINT32_LE.get(buf, off + 16),\n        // reserved for later use (must be zero)\n        reserved: new strtok.BufferType(12).get(buf, off + 20) // ToDo: what is this???\n      };\n    }\n  };\n\n  public static TagField = (footer) => {\n    return new strtok.BufferType(footer.size - Structure.TagFooter.len);\n  }\n\n  public static parseTagFlags(flags): ITagFlags {\n    return {\n      containsHeader: Structure.isBitSet(flags, 31),\n      containsFooter: Structure.isBitSet(flags, 30),\n      isHeader: Structure.isBitSet(flags, 31),\n      readOnly: Structure.isBitSet(flags, 0),\n      dataType: (flags & 6) >> 1\n    };\n  }\n\n  /**\n   * @param num {number}\n   * @param bit 0 is least significant bit (LSB)\n   * @return {boolean} true if bit is 1; otherwise false\n   */\n  public static isBitSet(num, bit): boolean {\n    return (num & 1 << bit) !== 0;\n  }\n\n}\n\ninterface IApeInfo {\n  descriptor?: IDescriptor,\n  header?: IHeader,\n  footer?: IFooter\n};\n\nclass ApeParser implements IStreamParser {\n\n  public static getInstance(): ApeParser {\n    return new ApeParser();\n  }\n  /**\n   * Calculate the media file duration\n   * @param ah ApeHeader\n   * @return {number} duration in seconds\n   */\n  public static calculateDuration(ah: IHeader): number {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n\n  private type: HeaderType = 'APEv2'; // ToDo: versionIndex should be made dynamic, APE may also contain ID3\n\n  private ape: IApeInfo = {};\n\n  public parse(stream, callback: TagCallback, done?, readDuration?, fileSize?) {\n\n    strtok.parse(stream, (v, cb) => {\n      if (v === undefined) {\n        cb.state = 'descriptor';\n        return Structure.DescriptorParser;\n      }\n\n      switch (cb.state) {\n        case 'descriptor':\n          if (v.ID !== 'MAC ') {\n            throw new Error('Expected MAC on beginning of file'); // ToDo: strip/parse JUNK\n          }\n          this.ape.descriptor = v;\n          const lenExp = v.descriptorBytes - Structure.DescriptorParser.len;\n          if (lenExp > 0) {\n            cb.state = 'descriptorExpansion';\n            return new strtok.IgnoreType(lenExp);\n          } else {\n            cb.state = 'header';\n            return Structure.Header;\n          }\n\n        case 'descriptorExpansion':\n          cb.state = 'header';\n          return Structure.Header;\n\n        case 'header':\n          this.ape.header = v;\n          callback('format', 'dataformat', 'ape');\n          callback('format', 'lossless', true);\n          callback('format', 'headerType', this.type);\n          callback('format', 'bitsPerSample', v.bitsPerSample);\n          callback('format', 'sampleRate', v.sampleRate);\n          callback('format', 'numberOfChannels', v.channel);\n          callback('format', 'duration', ApeParser.calculateDuration(v));\n          const forwardBytes = this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n            this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes;\n          cb.state = 'skipData';\n          return new strtok.IgnoreType(forwardBytes);\n\n        case 'skipData':\n          cb.state = 'tagFooter';\n          return Structure.TagFooter;\n\n        case 'tagFooter':\n          if (v.ID !== 'APETAGEX') {\n            done(new Error('Expected footer to start with APETAGEX '));\n          }\n          this.ape.footer = v;\n          cb.state = 'tagField';\n          return Structure.TagField(v);\n\n        case 'tagField':\n          this.parseTags(this.ape.footer, v, callback);\n          done();\n          break;\n\n        default:\n          done(new Error('Illegal state: ' + cb.state));\n      }\n      return 0;\n    });\n  };\n\n  private parseTags(footer: IFooter, buffer: Buffer, callback) {\n    let offset = 0;\n\n    for (let i = 0; i < footer.fields; i++) {\n      const size = strtok.UINT32_LE.get(buffer, offset);\n      offset += 4;\n      const flags = Structure.parseTagFlags(strtok.UINT32_LE.get(buffer, offset));\n      offset += 4;\n\n      let zero = common.findZero(buffer, offset, buffer.length);\n      const key = buffer.toString('ascii', offset, zero);\n      offset = zero + 1;\n\n      switch (flags.dataType) {\n        case DataType.text_utf8: { // utf-8 textstring\n          const value = buffer.toString('utf8', offset, offset += size);\n          const values = value.split(/\\x00/g);\n\n          /*jshint loopfunc:true */\n          for (const val of values) {\n            callback(this.type, key, val);\n          }\n        }\n          break;\n\n        case DataType.binary: { // binary (probably artwork)\n          if (key === 'Cover Art (Front)' || key === 'Cover Art (Back)') {\n            const picData = buffer.slice(offset, offset + size);\n\n            let off = 0;\n            zero = common.findZero(picData, off, picData.length);\n            const description = picData.toString('utf8', off, zero);\n            off = zero + 1;\n\n            const picture = {\n              description,\n              data: new Buffer(picData.slice(off))\n            };\n\n            offset += size;\n            callback(this.type, key, picture);\n          }\n        }\n          break;\n\n        default:\n          throw new Error('Unexpected data-type: ' + flags.dataType);\n      }\n    }\n  }\n}\n\nmodule.exports = ApeParser.getInstance();\n"]}